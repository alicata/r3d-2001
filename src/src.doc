// //////////////////////////////////////////////////////////
// file name: crust.h
//
// author:			Aaron Licata
// creation date:	14/02/01
// last modified:	16/02/01
// version number:	2
//
// description: crust algorithm related interface file
//
// //////////////////////////////////////////////////////////


#ifndef CRUST_RECONSTRUCTOR_H
#define CRUST_RECONSTRUCTOR_H


#include "interface.h"


// //////////////////////////////////////////////////////////
// file name: MedialAxisTransformer
//
// author:			Aaron Licata
// creation date:	14/02/01
// last modified:	21/04/01
// version number:	2
//
// description: class that implements the medial axis 
//
// //////////////////////////////////////////////////////////

class MedialAxisTransformer : public GeometryBuilderInterface
{
public:
	void Build(TetraList& tetraList) { DoMedialAxisTransform(tetraList); }

public:
	void DoMedialAxisTransform(TetraList& tetraList);
	int GetNumPoles();

	void FindPolesFromDelaunayVertex(int sampleId, Vertex3& pplus, Vertex3& pminus);

private:

};



// //////////////////////////////////////////////////////////
// file name: CrustExtractor
//
// author:			Aaron Licata
// creation date:	14/02/01
// last modified:	21/04/01
// version number:	2
//
// description: class that implements the crust extractor 
//
// //////////////////////////////////////////////////////////

class CrustExtractor : public GeometryBuilderInterface
{
public:
	void Build(TetraList& tetraList) { assert(0); }
	Vertex3* PerformCrustExtraction(TetraList& tetraList, int& destSize);
	void ExtractPolygonMesh(TetraList& tetraList, Skeleton* obj);
    

private:
	Vertex3* IntegratePolesIntoVertexArray(TetraList& tetraList, int totalNumPoles);
	Vertex3* CloneToLargerVertexArray(unsigned int additionalSize);

};


#endif

// ///////////////////////////////////////////////////////////
// file name: crust.cpp
//
// author:			Aaron Licata
// creation date:	14/02/01
// last modified:	18/02/01
// version number:	3
//
// description: crust algorithm related implementation module
//
// ///////////////////////////////////////////////////////////

#include "config.h"		
#include "math.h"		// DotProduct3
#include "geom.h"		// Vertex3
#include "geomutil.h"	// IsFaceClockWise
#include "delaunay.h"	// IsFaceOnConvexHull
#include "crust.h"		

int numPoles = 0;


// ///////////////////////////////////////////////////////////
// function: FindPolesFromDelaunayVertex()
//
// creation date:	14/02/01
// last modified:	06/04/01
// purpose: find the two poles from a Delaunay vertex (site)
//
// note: sample point and Delaunay vertex is the same
//
// arguments: sampleId is an index to the vertex list
//            poleMinus is one of the two poles
//			  polePlus is the other pole
//
// return value: none
// ///////////////////////////////////////////////////////////
void MedialAxisTransformer::FindPolesFromDelaunayVertex(int sampleId, Vertex3& poleMinus, Vertex3& polePlus)
{
	Vector3 normal;						// surface normal to sample point
	Vector3 spPlus;						// vector from pole+ to sample point
	Vertex3 *samplePoint;				// sample point (Delaunay vertex)
	Vertex3 *pPlus;						// reference to p+
	Vertex3 *pMinus;					// reference to p-
	double maxExternalMagnitude = 0.0;	// initialize longest external vector
	double maxInternalMagnitude = 0.0;	// initialize longest internal vector
	Tetrahedron *plusTetra = NO_LINK;	// tetra for pole+
	Tetrahedron *minusTetra = NO_LINK;	// tetra for pole-
	
	// find star and end of Voronoi 3-d cell VC(s) of sample point
	samplePoint = Vertex3::GetVertex(sampleId);
	TetraList::Itr startItr = samplePoint->neigh->Begin();
	TetraList::Itr endItr = samplePoint->neigh->End();
	if (startItr == endItr)
	{
     // this Delaunay vertex (sample point) has not neighbouring Voronoi vertices
		return;
	}

    // sample point does not lie on convex-hull
	if (!IsVertexOnConvexHull(sampleId))
	{
		// pole+ is furthest Voronoi vertex of VC(s) from sample point
		while (startItr != endItr)
		{
			// get Voronoi vertex
			Tetrahedron *tetra = *startItr++;
			Vertex3* pVoronoiVertex = tetra->GetCentre();

			// find distance from this Voronoi vertex to the one sample point
			Vector3 temp(pVoronoiVertex->x-samplePoint->x, pVoronoiVertex->y-samplePoint->y, pVoronoiVertex->z-samplePoint->z);
			double spPlusMagnitude = temp.Magnitude();

			// find the largest vector so far
			if (spPlusMagnitude > maxExternalMagnitude)
			{
				maxExternalMagnitude = spPlusMagnitude; // save largest distance

				spPlus.Set(temp.x, temp.y, temp.z);		// save largest vector
				
				// update destination pole to passed to this function
				polePlus.x = pVoronoiVertex->x; 
				polePlus.y = pVoronoiVertex->y;
				polePlus.z = pVoronoiVertex->z;


				pPlus = pVoronoiVertex; // save best vv candidate to be pole
				plusTetra = tetra;
			}
		}
		// normal is vector sp+ from pole+ to sample point
		normal.Set(spPlus.x, spPlus.y, spPlus.z);

		// flagg tetrahedron and its vv as pole 
		plusTetra->Flagged(true);
		if (!plusTetra->GetCentre()->IsPole())
		{
			plusTetra->GetCentre()->SetPole(true);
			numPoles++;
		}

	}
	else // sample point lies on convex-hull
	{
		// ignore pole+ (i.e. pole+ is at infinity)
		polePlus.x = INFINITY;
		polePlus.y = INFINITY;
		polePlus.z = INFINITY;

		// normal is  average of outer normals of adjecent faces
		FindAverageNormalFromAdjecentFaces(sampleId, normal);
		normal.Normalize();

		// save normal for later stages
		Vertex3* vertex = Vertex3::GetVertex(sampleId);
		vertex->normal.Set(normal);
	}    
	
    //  for each Voronoi vertex in the 3-D Voronoi cell
	for (startItr = samplePoint->neigh->Begin(); startItr != endItr; startItr++)
	{
		// determine vector from Voronoi vertex to sample point
		Tetrahedron *tetra = *startItr;
		Vertex3 voronoiVertex = tetra->Centre(); 

		// SP- = vector from Voronoi vertex to sample point 
		Vector3 spMinus(voronoiVertex.x-samplePoint->x, voronoiVertex.y-samplePoint->y, voronoiVertex.z-samplePoint->z);

		// determine whether a vector is internal or external to surface
		// inner pole: dot product between vector SP- and normal is negative
		if (DotProduct3(&spMinus, &normal) < 0)
		{
			// If SP- Is Longest Internal Vector
			double spMinusMagnitude = spMinus.Magnitude();

			// enstablish longest internal vector
			if (spMinusMagnitude > maxInternalMagnitude)
			{
				maxInternalMagnitude = spMinusMagnitude;

				// pole- = current Voronoi vertex
				poleMinus.x = voronoiVertex.x;
				poleMinus.y = voronoiVertex.y;
				poleMinus.z = voronoiVertex.z;
				// store reference to current farthest
				pMinus = &voronoiVertex;
				minusTetra = tetra;
			}
		}
	}
    if (minusTetra != NO_LINK)
	{
		minusTetra->Flagged(true);
		if (!minusTetra->GetCentre()->IsPole())
		{
			minusTetra->GetCentre()->SetPole(true);
			numPoles++;
		}

	}
	// end of for Voronoi cell loop
}



// ///////////////////////////////////////////////////////////
// function: GetNumPoles()
//
// creation date:	19/04/01
// last modified:	19/04/01
// purpose: returns the number of poles computed by MedialAxis
//
// arguments: none

// return value: number of poles
// ///////////////////////////////////////////////////////////

int MedialAxisTransformer::GetNumPoles()
{
	return numPoles;
}



// ///////////////////////////////////////////////////////////
// function: DoMedialAxisTransform()
//
// creation date:	18/02/01
// last modified:	18/02/01
// purpose: find Voronoi vertices of Medial Axis 
//
// arguments: tetraList is the list of current tetrahedra
//
// return value: none
// ///////////////////////////////////////////////////////////

void MedialAxisTransformer::DoMedialAxisTransform(TetraList& tetraList)
{
	Vertex3 polePlus;
	Vertex3 poleMinus;

	numPoles = 0;
	


	for (int vertexId = 0; vertexId < Vertex3::GetGlobalVertexCount(); vertexId++)
	{
		poleMinus.SetVertex(0.0, 0.0, 0.0);
		polePlus.SetVertex(0.0, 0.0, 0.0);
		FindPolesFromDelaunayVertex(vertexId, poleMinus, polePlus);	
	}
}



// ///////////////////////////////////////////////////////////
// function: CloneToLargerVertexArray()
//
// creation date:	18/04/01
// last modified:	18/04/01
// purpose: resize vertex array by allocating a new larger array
//          and copy the contents of the old array to the new one
//
// arguments: the new additional size (how much should the array
// be expanded).
//
// return value: new vertex array
// ///////////////////////////////////////////////////////////

Vertex3* CrustExtractor::CloneToLargerVertexArray(unsigned int additionalSize)
{
	unsigned int oldSize = Vertex3::GetGlobalVertexCount();

	// allocate new vertex array
	unsigned int newSize = oldSize + additionalSize;
	Vertex3* newArray = new Vertex3[newSize+4]; // add four extra vertices of supertetra 
	if (!newArray)
	{
		return NULL;
	}

	// copy contents of old array into new array
	for (int i = 0; i < oldSize; i++)
	{
		Vertex3* oldVertex = Vertex3::GetVertex(i);

		//oldVertex->CopyTo(newArray[i]); // this function is not working
		newArray[i].x = oldVertex->x;
		newArray[i].y = oldVertex->y;
		newArray[i].z = oldVertex->z;

		newArray[i].normal.x = oldVertex->normal.x;
		newArray[i].normal.y = oldVertex->normal.y;
		newArray[i].normal.z = oldVertex->normal.z;

	}

	return newArray;
}



// ///////////////////////////////////////////////////////////
// function: IntegratePolesIntoVertexArray()
//
// creation date:	18/04/01
// last modified:	18/04/01
// purpose: add the poles to the global vertex array
//
// arguments: tetrahedron list where the poles are stored
//			  total number of poles to add to the global vertex array 
//
// return value: new vertex array
// ///////////////////////////////////////////////////////////

Vertex3* CrustExtractor::IntegratePolesIntoVertexArray(TetraList& tetraList, int totalNumPoles)
{
	int oldSize = Vertex3::GetGlobalVertexCount();
	int newSize;

	// resize the global vertex array
	Vertex3* newArray = CloneToLargerVertexArray(totalNumPoles);
	if (!newArray)
	{
		// not enough primary memory available
		return false;
	}
	newSize = oldSize + totalNumPoles;


	TetraList::Itr start = tetraList.Begin();
	TetraList::Itr end = tetraList.End();

	int newVertexId = oldSize;
        int count = 0;
	
	while (start != end)
	{
		Tetrahedron *tetra = *start++;
		
		// copy pole coordinates to a vertex in the new  
		// vertex array
		if (tetra->GetCentre()->IsPole())
		{
			Vertex3* currentVertex = &newArray[newVertexId];
			newVertexId++;
			count++;
			currentVertex->SetVertex(*(tetra->GetCentre()));
			currentVertex->pole = true;
		}
	}
	

	assert(totalNumPoles == count);
	assert(newVertexId <= newSize);

	return newArray;
}




// ///////////////////////////////////////////////////////////
// function: Build()
//
// creation date:	18/04/01
// last modified:	18/04/01
// purpose: extract the crust from the point set and its poles
//
// arguments: none
//
// return value: true successful allocation, false not successful
// ///////////////////////////////////////////////////////////

Vertex3* CrustExtractor::PerformCrustExtraction(TetraList& tetraList, int& destArraySize)
{

	int oldSize = Vertex3::GetGlobalVertexCount();

	assert(numPoles > 0 );

	// assume the Medial Axis has already been calculated
	Vertex3* destinationArray = IntegratePolesIntoVertexArray(tetraList, numPoles);
        if (!destinationArray)
	{
		// not enough memory
		return NULL;
	}

	destArraySize = oldSize + numPoles;
    
	return destinationArray;
}



// ///////////////////////////////////////////////////////////
// function: ExtractPolygonMesh()
//
// creation date:	23/04/01
// last modified:	23/04/01
// purpose: extract the polygon mesh from the union of vertices and poles
//
// arguments: the list of tetrahedra and the destination mesh object

// return value: none
// ///////////////////////////////////////////////////////////

void CrustExtractor::ExtractPolygonMesh(TetraList& tetraList, Skeleton* obj)
{

	TetraList::Itr start = tetraList.Begin();
	TetraList::Itr end = tetraList.End();
	

	/////////////////////////////////////////////////
	// find how many crust faces (triangles) there are and 
	// allocate a corresponding face array
	
	obj->faceCount = 0;
	obj->faceIndex = NULL;

	while (start != end)
	{
		Tetrahedron *tetra = *start++;
		
		for (int i = 0; i < 4; i++)
		{
			Face3 *face = tetra->F(i);
			
			// ignore faces with pole vertices and process 
			//  only faces with vertices from original samples
			// because they represent the reconstructed surface

			Vertex3* v0 = face->V(0);
			Vertex3* v1 = face->V(1);
			Vertex3* v2 = face->V(2);

			if (!v0->IsPole() && !v1->IsPole() && !v2->IsPole())
			{
				obj->faceCount++;
			}
		}
	}
	obj->faceIndex = new unsigned long [obj->faceCount*3];
	// note: vertexCount = faceCount*3
	/// //////////////////////////////////////////////////


	// now extract crust faces from Delaunay simplicial complex
	// and place crust faces into the new face array as indices
	start = tetraList.Begin();
	end = tetraList.End();
	int vertexCount = 0;

        while (start != end)
	{
		Tetrahedron *tetra = *start++;
		
		for (int i = 0; i < 4; i++)
		{
			Face3 *face = tetra->F(i);
			
			// ignore faces with pole vertices and process 
			//  only faces with vertices from original samples
			// because they represent the reconstructed surface

			Vertex3* v0 = face->V(0);
			Vertex3* v1 = face->V(1);
			Vertex3* v2 = face->V(2);

			if (!v0->IsPole() && !v1->IsPole() && !v2->IsPole())
			{
				obj->faceIndex[vertexCount+0] = face->I(0);
				obj->faceIndex[vertexCount+1] = face->I(1);
				obj->faceIndex[vertexCount+2] = face->I(2);

				vertexCount += 3;

				// calculate normal if not aleardy done so
				// use vertex index as source of information
				// and place result direclty into v->normal
				if (v0->normal.Magnitude() == 0.0)
				{
					FindAverageNormalFromAdjecentFaces(face->I(0), v0->normal);
				}
				if (v1->normal.Magnitude() == 0.0)
				{
					FindAverageNormalFromAdjecentFaces(face->I(1), v1->normal);
				}
				if (v2->normal.Magnitude() == 0.0)
				{
					FindAverageNormalFromAdjecentFaces(face->I(2), v2->normal);
				}
			}
		}
	}
	assert((vertexCount) == (obj->faceCount*3));
    tetraList.DeleteAll();
}

// ////////////////////////////////////////////////////////////////
// delaunay.h
//
// author:			Aaron Licata
// creation date:	30/08/00
// last modified:	30/08/00
//
// Header file for delaunay tetrahedralization 
// 
// /////////////////////////////////////////////////////////////////
#ifndef DELAUNAY_H
#define DELAUNAY_H

#include <list>
#include "STL.h"
#include "geom.h"
#include "interface.h"


// flags to distinguish between non-degenerate and degenerate intersection cases
#define DELAUNAY_CIRCUMSPHERE_NOT_INTERSECTED 0
#define DELAUNAY_CIRCUMSPHERE_INTERSECTED 1
#define DELAUNAY_CIRCUMSPHERE_REJECTED 2



// ////////////////////////////////////////////////////////////////
// class DelaunayTetrahedralizer 
//
// author:			Aaron Licata
// creation date:	30/08/00
// last modified:	21/04/01
//
// purpose: class for building a Delaunay tetrahedralization
// 
// /////////////////////////////////////////////////////////////////

class DelaunayTetrahedralizer : public GeometryBuilderInterface
{
private:

	// geometry builder interface
public:
	void Build(TetraList& tetraList);

	// other operatatoins
public:
	SuperTetra& GetSuperTetra() { return superTetra; }

private:	
	int CircumsphereIsIntersected(Tetrahedron *tetra, int pointIndex);
	Tetrahedron* CreateSuperTetrahedron(Vertex3* vert, int numVerts);
	void RetainSinglyOccurringFaces(list<Face3*> &faces);
	void CreateTetrahedronFrom4FacesAndPoint(list<Face3*> &faces, int pointIndex, TetraList &tetras);
	void CreatedAndWireTetrahedraFromSOF(list<Face3*> &faces, int pointIndex, TetraList& tetras);
	void CreatedAndWireTetrahedraFromSOF2(list<Face3*> &faces, int pointIndex, TetraList& tetras);
	void FlagAndDeleteBallSeededTetrahedra(TetraList &tetras, int pointIdex, list<Face3*> &temp);
	void DeleteArbitraryBoundaryFaces(TetraList &tetraList);

private:
	void RewireNeighbouringTetrahedron(Tetrahedron *tetra, Face3* externalFace);
    void WireTetrahedron(TetraList::RevItr startTetraItr, TetraList::RevItr stopTetraItr, TetraList::RevItr newTetraItr);
	void WireTetrahedron2(TetraList::Itr& startTetraItr, TetraList::Itr& stopTetraItr, TetraList::Itr& newTetraItr);
	void FlagTetrahedronForDeletion(TetraList::Itr tetraItr);
	void DeleteFlaggedTetrahedra(TetraList& tetraList, TetraList::Itr firstItr, TetraList::Itr lastItr, TetraList::Itr notFound);
	void RestoreFlaggedTetrahedra(TetraList::Itr firstItr, TetraList::Itr lastItr, TetraList::Itr notFound);
	bool IsTetraTouchingSuperBoundary(Tetrahedron *tetra, Vertex3* a[4]);

private:
	double machineTollerance;
	SuperTetra superTetra;
};



// ////////////////////////////////////////////////////////////////
// class VoronoiTessellator
//
// author:			Aaron Licata
// creation date:	30/08/00
// last modified:	21/04/01
//
// purpose: class for building a Voronoi Tessellation
// 
// /////////////////////////////////////////////////////////////////
class VoronoiTessellator : public GeometryBuilderInterface
{
private:

	// geometry builder interface
public:
	void Build(TetraList& tetraList);

	// other operatatoins
public:
	void LinkVerticesToNeighTetrahedra(TetraList &tetraList);

private:
	void WireTwoNeighbouringTetrahedra(int faceIndex, Tetrahedron* someTetra, Tetrahedron* tetra, int& faceCount);
	void FindNeighbouringFaces(TetraList& tetraList, Tetrahedron* tetra);

};




#endif
// ///////////////////////////////////////////////////////////
// delaunay.cpp
//
// author:			Aaron Licata
// creation date:	30/08/00
// last modified:	30/12/00
//
// Implementation file for watson algorihm and its subroutines
//
// ///////////////////////////////////////////////////////////

#include "config.h"
#include <math.h>		// abs
#include "math.h"		// MACHINE_TOLLERANCE
#include "geom.h"		// Tetrahedron, Face3, Edge3
#include "geomutil.h"	// BoundBox3, MaxBox3
#include "apperr.h"		// AppError
#include "appio.h"		// AppOut, AppEndl
#include "delaunay.h"	// list<T>
#include <algorithm>	// count
#include <vector>		// vector<T>
#include "STL.h"		// enable native STL version 
#include <iostream>



// ///////////////////////////////////////////////////////////
// function: CreateSuperTetrahedron
//
// purpose: allocate and setup the super tetrahedron enclosing
// all data points.
//
// arguments: Tetrahedron* & super
//
// ///////////////////////////////////////////////////////////

Tetrahedron * DelaunayTetrahedralizer::CreateSuperTetrahedron(Vertex3* vert, int numVerts)
{
	BoundBox3 boundBox;
	MaxBox3(boundBox, vert, numVerts);

	boundBox.CenterAtOrigin();

	double h = boundBox.MaxX() + boundBox.MaxY() + boundBox.MaxZ();
	double densityRatio = boundBox.MaxX() * boundBox.MaxY() * boundBox.MaxZ();


	machineTollerance = CalculateMachineTollerance();

	if (fabs(h) < machineTollerance)
		AppError(APPERR_INSUFFICIENT_SAMPLE_DENSITY);
	else if (fabs(densityRatio) < MACHINE_TOLLERANCE)
	{
		AppOut("density ratio is");
		AppOut(fabs(densityRatio)) ;
		AppEndl();
		AppError(APPERR_2D_OR_1D_SAMPLES);
	}
	
	// ////////////// super tetrahedron /////////////////////////
	// possible improvement: calculate best scaling factor
	// the current implementation just overwrite scaling factor
	h = (double)superTetra.GetSuperFactor();
	// calculate coordinates of supertetra vertices	
	Vertex3 vApex    (    0.0,  4*h,  0.0);
	Vertex3 vBaseLeft( -4*h, -4*h, +4*h);
	Vertex3 vBaseRight(+4*h, -4*h, +4*h);
	Vertex3 vBaseBack(    0, -4*h, -4*h);
	superTetra.Set(vApex, vBaseLeft, vBaseRight, vBaseBack);
	// ////////////////////////////////////////////////////////////

	// indices to vertices added to vertex list
	int apex  = 0 + numVerts;
	int left  = 1 + numVerts;
	int right = 2 + numVerts;
	int back  = 3 + numVerts;

	// update vertex list
	
	COPYVERTS(  vert[apex] , vApex  );
	COPYVERTS(	vert[left] , vBaseLeft  );
	COPYVERTS(	vert[right] , vBaseRight  );
	COPYVERTS(	vert[back] , vBaseBack  );
	numVerts += 4;
	Vertex3::SetGlobalVertexCount(numVerts);

	Face3 f0(left, right, back);
	Face3 f1(left, apex, back);
	Face3 f2(right, back, apex);
	Face3 f3(left, right, apex);

	// initialize to a tetra with no neighbours
	f0.neigh = NO_LINK;
	f1.neigh = NO_LINK;
	f2.neigh = NO_LINK;
	f3.neigh = NO_LINK;

	Tetrahedron *tetra = new Tetrahedron(f0, f1, f2, f3);
	if (!tetra) AppError(APPERR_TETRA_ALLOC);
	tetra->SetLocalVertexList(vert);
	
	return tetra;
}

// ///////////////////////////////////////////////////////////
// function: RetainSinglyOccurringFaces()
//
// creation date:	09/09/00
// last modified:	11/02/00
// purpose: filter out any double face in the list
//
// note: a double face, is a face that is present twice in the list
//
// arguments: tetralist is the list of all existing tetrahedra
// ///////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::RetainSinglyOccurringFaces(list<Face3*> &faces)
{
	 // NOTE: the face list must contain at least two
	 // faces

	 list<Face3*> singles;
     list<Face3*>::iterator startIter;
     list<Face3*>::iterator endIter;
	 
	 //AppOut("RetainSinglyOcc entered\n");
	 bool doubleFound = false;

	 while (faces.size() > 0)
	 {
		 startIter = faces.begin();
		 endIter = faces.end();

		 //AppOut("SinglyOccurring: Detecting a double occurrance...\n");
		 doubleFound = false;
		 list<Face3*>::iterator currentIter = startIter;
		 currentIter++;
		 for (; currentIter != endIter; currentIter++)
		 {
			//number = count(start, end, *start);
			Face3 *curFace = *currentIter;
			Face3 *startFace = *startIter;
			if (*curFace == *startFace)
			{
				doubleFound = true;
				break;
			}
		 }
	 
		 // found double faces
		 // in this case erease the two faces pointers 
		 // from the temporary list.
		 // also, the actual objects pointed to must
		 // be deleted
		 if (doubleFound)
		 {
		 //AppOut("SinglyOccurring: Removing double faces...\n");
			// get rid of face objects first
			delete *startIter;
			delete *currentIter;
			// now erase face pointers in the temprary list
			faces.erase(startIter);
			faces.erase(currentIter);
			
			// iterators are now invalid
			// they need to be assigned again
		 }
		 // current face is single
		 else
		 {
			 singles.push_back(*startIter);
			 faces.pop_front();
		 }
	 }
		
	 faces = singles;

	//AppOut(" temp list size: "); 
	//AppOut((int)faces.size());
	//AppEndl();
}



// ///////////////////////////////////////////////////////////
// function: CreateTetrahedronFrom4FacesAndPoint()
//
// creation date:	09/09/00
// last modified:	11/02/00
// purpose: create a new tetrahedron using four faces
//
// arguments: list of four faces
//            tetralist is the list of all existing tetrahedra
// ///////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::CreateTetrahedronFrom4FacesAndPoint(list<Face3*> &faces, int pointIndex, TetraList& tetras)
{
	while (!faces.empty())
	{
		// create a new tetrahedron out of the single faces.
		// memory management note: each of the faces referenced
		// in the temporary list of faces is kept as it is
		// and other three faces are actually allocated.
		// So, in the end, each tetrahedron has one link to a face 
		// that already existed (allocated) and three links to 
		// newly allocated faces.
		Face3 *f0 = faces.back();
		faces.pop_back();
		Face3 *f1 = new Face3(f0->I(0), f0->I(1), pointIndex);
		Face3 *f2 = new Face3(f0->I(1), f0->I(2), pointIndex);
		Face3 *f3 = new Face3(f0->I(2), f0->I(0), pointIndex);
		tetras.Add(new Tetrahedron(f0, f1, f2, f3));
	}
	//AppOut("aftger tetra creat ");
	//AppOutN((int)faces.size());

	//cout << "after tetra creatoin: " << faces.size() << endl; 
}



// ///////////////////////////////////////////////////////////
// function: RewireNeighbouringTetrahedron()
//
// creation date:	09/11/00
// last modified:	11/12/00
// purpose: link neighbouring tetrahedron
//
// arguments: tetrahedron and face
//          
// ///////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::RewireNeighbouringTetrahedron(Tetrahedron *tetra, Face3* externalFace)
{
	Tetrahedron* neighTetra = externalFace->neigh;

	// find which face is shared by the tetra and its neigbhour
	// then link the neighbouring tetrahedron to this neighbour
#ifdef _DEBUG_STRICT
	assert(neighTetra);
#endif

	//AppOut("start loop");
	//AppEndl();
	for (int i = 0; i < 4; i++)
	{
		//AppOut("for count "); 
		//AppOut(i);
		//AppEndl();
		if (neighTetra != NO_LINK)
		{
			//AppOutN("neighTetra != NO_LINK");
			Face3 *neighFace = neighTetra->F(i);
			//AppOutN("Face3 *neighFace = neighTetra->F(i)");
			assert(neighFace);
			if (*neighFace == *externalFace)
			{
				//AppOutN("if (*neighFace == *externalFace)");
				neighFace->neigh = tetra; 
				return;
			}
		}
	}
#ifdef _DEBUG_STRICT
	int NO_TETRA_FACES_FOUND = 0;
	assert(NO_TETRA_FACES_FOUND);
#endif
	
}



// ///////////////////////////////////////////////////////////
// function: WireTetrahedron()
//
// creation date:	09/12/00
// last modified:	11/12/00
// purpose: link tetrahedron to face neighbours
//
// arguments: tetraList iterators
//            
// ///////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::WireTetrahedron(TetraList::RevItr startTetraItr, TetraList::RevItr stopTetraItr, TetraList::RevItr newTetraItr)
{
	Face3 *f1 = (*newTetraItr)->F(1);
	Face3 *f2 = (*newTetraItr)->F(2);
	Face3 *f3 = (*newTetraItr)->F(3);

	int numProcessedFaces = 0;
	while (startTetraItr != stopTetraItr)
	{
		Face3 *nf1 = (*startTetraItr)->F(1);
		Face3 *nf2 = (*startTetraItr)->F(2);
		Face3 *nf3 = (*startTetraItr)->F(3);

		numProcessedFaces++;
		// if this face is same as one of those in
		// an internal tetrahedron
		// face1
		if (*f1 == *nf1)
		{
			nf1->neigh = *newTetraItr;
			f1->neigh = *startTetraItr;
		}
		else if (*f1 == *nf2)
		{
			nf2->neigh = *newTetraItr;
			f1->neigh = *startTetraItr;
		}
		else if (*f1 == *nf3)
		{
			nf3->neigh = *newTetraItr;
			f1->neigh = *startTetraItr;
		}
		// face 2
		if (*f2 == *nf1)
		{
			nf1->neigh = *newTetraItr;
			f2->neigh = *startTetraItr;
		}
		else if (*f2 == *nf2)
		{
			nf2->neigh = *newTetraItr;
			f2->neigh = *startTetraItr;
		}
		else if (*f2 == *nf3)
		{
			nf3->neigh = *newTetraItr;
			f2->neigh = *startTetraItr;
		}
		// face 3
		if (*f3 == *nf1)
		{
			nf1->neigh = *newTetraItr;
			f3->neigh = *startTetraItr;
		}
		else if (*f3 == *nf2)
		{
			nf2->neigh = *newTetraItr;
			f3->neigh = *startTetraItr;
		}
		else if (*f3 == *nf3)
		{
			nf3->neigh = *newTetraItr;
			f3->neigh = *startTetraItr;
		}
#ifdef _DEBUG_STRICT
		else
		{
			int NOT_ABLE_TO_LINK_FACES_AND_TETRA = 0;
			assert(NOT_ABLE_TO_LINK_FACES_AND_TETRA);
		}
#endif

		startTetraItr--;
	}
	// end of while loop
#ifdef _DEBUG_STRICT1
	assert((numProcessedFaces % 3) == 0);
#endif

#ifdef _DEBUG_APPOUT
	AppOut("numProcessedFaces = ");
	AppOut(numProcessedFaces);
	AppEndl();
#endif
}

// ///////////////////////////////////////////////////////////
// function: WireTetrahedron2()
//
// purpose: wire internal faces to thier neighbouring tetrahedra
//
void DelaunayTetrahedralizer::WireTetrahedron2(TetraList::Itr& startTetraItr, TetraList::Itr& stopTetraItr, TetraList::Itr& newTetraItr)
{
	Face3 *f1 = (*newTetraItr)->F(1);
	Face3 *f2 = (*newTetraItr)->F(2);
	Face3 *f3 = (*newTetraItr)->F(3);

	int numProcessedFaces = 0;
	while (startTetraItr != stopTetraItr)
	{
		Face3 *nf1 = (*startTetraItr)->F(1);
		Face3 *nf2 = (*startTetraItr)->F(2);
		Face3 *nf3 = (*startTetraItr)->F(3);

		numProcessedFaces++;

		// avoid checking against the same tetrahedron'faces
		if (*newTetraItr == *startTetraItr)
		{
			//startTetraItr++;
			//continue;
		}

		// if this face is same as one of those in
		// an internal tetrahedron
		// face1
		if (*f1 == *nf1)
		{
			nf1->neigh = *newTetraItr;
			f1->neigh = *startTetraItr;
		}
		else if (*f1 == *nf2)
		{
			nf2->neigh = *newTetraItr;
			f1->neigh = *startTetraItr;
		}
		else if (*f1 == *nf3)
		{
			nf3->neigh = *newTetraItr;
			f1->neigh = *startTetraItr;
		}
		/*
#ifdef _DEBUG_STRICT
		else
		{
			int NOT_ABLE_TO_LINK_FACE1_AND_TETRA = 0;
			assert(NOT_ABLE_TO_LINK_FACE1_AND_TETRA);
		}
#endif
		*/

		// face 2
		if (*f2 == *nf1)
		{
			nf1->neigh = *newTetraItr;
			f2->neigh = *startTetraItr;
		}
		else if (*f2 == *nf2)
		{
			nf2->neigh = *newTetraItr;
			f2->neigh = *startTetraItr;
		}
		else if (*f2 == *nf3)
		{
			nf3->neigh = *newTetraItr;
			f2->neigh = *startTetraItr;
		}
		/*
#ifdef _DEBUG_STRICT
		else
		{
			int NOT_ABLE_TO_LINK_FACE2_AND_TETRA = 0;
			assert(NOT_ABLE_TO_LINK_FACE2_AND_TETRA);
		}
#endif
		*/

		// face 3
		if (*f3 == *nf1)
		{
			nf1->neigh = *newTetraItr;
			f3->neigh = *startTetraItr;
		}
		else if (*f3 == *nf2)
		{
			nf2->neigh = *newTetraItr;
			f3->neigh = *startTetraItr;
		}
		else if (*f3 == *nf3)
		{
			nf3->neigh = *newTetraItr;
			f3->neigh = *startTetraItr;
		}
#ifdef _DEBUG_STRICT
		else
		{
			int NOT_ABLE_TO_LINK_FACEs123_AND_TETRA = 0;
			assert(NOT_ABLE_TO_LINK_FACEs123_AND_TETRA);
		}
#endif

		startTetraItr++;
	}
	// end of while loop

#ifdef _DEBUG_STRICT1
	assert((numProcessedFaces % 3) == 0);
#endif

#ifdef _DEBUG_APPOUT
	AppOut("numProcessedFaces = ");
	AppOut(numProcessedFaces);
	AppEndl();
#endif
}



// ////////////////////////////////////////////////////////////////////////
// CreatedAndWireTetrahedraFromSOF
// purpuse: create one new tetrahedron for each singly-occurring face (SOF) 
// in the filtered out temporary list of faces
//
// note: it is assumed that during the creation of the supertetrahdron its 
// faces have been intilialized to NO_LINK
// 
// /////////////////////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::CreatedAndWireTetrahedraFromSOF(list<Face3*> &faces, int pointIndex, TetraList& tetras)
{
#ifdef _DEBUG_STRICT
	int oldSize = (int)faces.size();
	assert( oldSize > 0);
#endif
	// current number of tetrahedra and nunber of new tetrahedra 
	int oldListSize = tetras.Size();
	int newTetraCount = 0;

	// PASS1:
	while (!faces.empty())
	{
		// create a new tetrahedron out of each of single faces.
		// memory management note: each of the faces referenced
		// in the temporary list of faces is kept as it is
		// and other three faces are actually allocated.
		// So, in the end, each tetrahedron has one link to a face 
		// that already existed (allocated) and three links to 
		// newly allocated faces.

		// +---------------+ +---------+
		// |               |-|f0  1 2 3|-> tetra T1 	(external face)
		// +               | +---------+
		// |               |-|f1  1 2 4|-> tetra T2	(internal face)
		// +  tetarhedron  | +---------+
		// |               |-|f2  1 3 4|-> tetra T3	(internal face)
		// +               | +---------+
		// |               |-|f3  2 3 4|-> tetra T4 	(internal face)
		// +---------------+ +---------+ 
	
		Face3 *f0 = faces.back();
		faces.pop_back();
		Face3 *f1 = new Face3(f0->I(0), f0->I(1), pointIndex);
		Face3 *f2 = new Face3(f0->I(1), f0->I(2), pointIndex);
		Face3 *f3 = new Face3(f0->I(0), f0->I(2), pointIndex);
		Tetrahedron *tetra = new Tetrahedron(f0, f1, f2, f3);
		tetras.Add(tetra);
		//AppOutN(newTetraCount);
		newTetraCount++;

		// external (boundary) face has a neighbouring tetrahedron
		// rewire neighbouring tetrahdron
		if (f0->neigh)
		{
			//AppOut("RewireNeighbouringTetrahedron(tetra, f0)");
			//AppEndl();
			assert(tetra);
			assert(f0);
			RewireNeighbouringTetrahedron(tetra, f0);
		}
	}

	// PASS2:
	// wire internal faces of new tetrahedra
	//TetraList::Itr lastOldItr = tetras.Begin();
	//lastOldItr = lastOldItr + (unsigned int)listSize;
	TetraList::RevItr stopTetraItr = tetras.Rend();
	TetraList::RevItr startTetraItr = tetras.Rbegin();
#ifdef _DEBUG_STRICT
	//assert( ((tetras.Last()-lastOldItr)/sizeof(TetraList::Itr)) == oldSize);
#endif
	
#ifdef _DEBUG_APPOUT1
		AppOut("********size of tetra list: ");
		AppOut(tetras.Size());
		AppEndl();
		AppOut("newTetraCount = ");
		AppOut(newTetraCount);
		AppEndl();
#endif

	int numLoops = 0;
	for (TetraList::RevItr newTetraItr = startTetraItr; (newTetraItr != stopTetraItr)&&(newTetraCount-- > 0); newTetraItr++)
	{
		WireTetrahedron(startTetraItr, stopTetraItr, newTetraItr);
#ifdef _DEBUG_APPOUT1
		numLoops++;
#endif
	}

#ifdef _DEBUG_APPOUT1
		//static int numLoops = 0;
	    AppOut("number of loops: ");
		AppOut(numLoops);
		AppEndl();
#endif 
	
	 
			

	//AppOut("aftger tetra creat ");
	//AppOutN((int)faces.size());

	//cout << "after tetra creatoin: " << faces.size() << endl; 
}



// ////////////////////////////////////////////////////////////////////////
// CreatedAndWireTetrahedraFromSOF
// purpuse: create one new tetrahedron for each singly-occurring face (SOF) 
// in the filtered out temporary list of faces
//
// note: it is assumed that during the creation of the supertetrahdron its 
// faces have been intilialized to NO_LINK
//
// ////////////////////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::CreatedAndWireTetrahedraFromSOF2(list<Face3*> &faces, int pointIndex, TetraList& tetras)
{
#ifdef _DEBUG_STRICT
	int oldSize = (int)faces.size();
	assert( oldSize > 0);
#endif
	// current number of tetrahedra and nunber of new tetrahedra 
	int newTetraCount = 0;
	int oldListSize = tetras.Size();
	// the id of the first of thew new tetrahedra
	int lowestNewId = 0;

#ifdef _DEBUG_STRICT
	// if tetraList is empty (just created supertetrahedron)
	// then first tetra iterator will be == tetras.End()
	assert( oldListSize >= 0);
#endif


	// find the last tetrahedron of the tetralist
	// this is going to be the starting marker for
	// the new sublist of new tetrahedra appended to tetralist
	/*
	TetraList::Itr firstNewTetraItr = tetras.Begin();
	TetraList::Itr oneBeforeItr = firstNewTetraItr;
	TetraList::Itr end = tetras.End();
	    
		AppOut("last tetrahedron tetra id: ");
		Tetrahedron* temp = *firstNewTetraItr;
		if (oldListSize>0)
		if (temp)
		{
			AppOut("new tetra id: ");
			AppOutN(temp->GetID());
		}
		else
		{
			AppOutN("first new tetra is NULL");
		}


		
	while (firstNewTetraItr != end) 
	{
		oneBeforeItr = firstNewTetraItr;
		firstNewTetraItr++;
	}
	firstNewTetraItr = oneBeforeItr;
		*/

	// PASS1:
	while (!faces.empty())
	{
		// create a new tetrahedron out of each of single faces.
		// memory management note: each of the faces referenced
		// in the temporary list of faces is kept as it is
		// and other three faces are actually allocated.
		// So, in the end, each tetrahedron has one link to a face 
		// that already existed (allocated) and three links to 
		// newly allocated faces.

		// +---------------+ +---------+
		// |               |-|f0  1 2 3|-> tetra T1 	(external face)
		// +               | +---------+
		// |               |-|f1  1 2 4|-> tetra T2	(internal face)
		// +  tetarhedron  | +---------+
		// |               |-|f2  1 3 4|-> tetra T3	(internal face)
		// +               | +---------+
		// |               |-|f3  2 3 4|-> tetra T4 (internal face)
		// +---------------+ +---------+ 
	
		Face3 *f0 = faces.back();
		faces.pop_back();
		Face3 *f1 = new Face3(f0->I(0), f0->I(1), pointIndex);
		Face3 *f2 = new Face3(f0->I(1), f0->I(2), pointIndex);
		Face3 *f3 = new Face3(f0->I(0), f0->I(2), pointIndex);
		Tetrahedron *tetra = new Tetrahedron(f0, f1, f2, f3);
		tetras.Add(tetra);
		//AppOutN(newTetraCount);
		// save the id of the first newly created tetrahedron
	    if (newTetraCount == 0)
		{
			lowestNewId = tetra->GetID();
		}
		newTetraCount++;

		// +---------------+ +---------+
		// |               |-|f0  1 2 3|-> tetra T1 	(external face)
		// +               | +---------+
		// |               |-|f1  1 2 4|-> ?
		// +  tetarhedron  | +---------+
		// |               |-|f2  1 3 4|-> ?
		// +               | +---------+
		// |               |-|f3  2 3 4|-> ?
		// +---------------+ +---------+ 
		// external (boundary) face has a neighbouring tetrahedron
		// rewire neighbouring tetrahdron
		if (f0->neigh)
		{
			//AppOut("RewireNeighbouringTetrahedron(tetra, f0)");
			//AppEndl();
			assert(tetra);
			assert(f0);
			RewireNeighbouringTetrahedron(tetra, f0);
		}
	}

	return;
	// PASS2:
	// wire internal faces of new tetrahedra
	//TetraList::Itr lastOldItr = tetras.Begin();
	//lastOldItr = lastOldItr + (unsigned int)listSize;

	// find the iterator to the first newly created tetra
	TetraList::Itr stopTetraItr = tetras.End();
	TetraList::Itr startTetraItr = tetras.Begin();
	while ((startTetraItr != stopTetraItr)&&(oldListSize>0))
	{
		// if tetra list is empty this while loop won't execute at all
		
		Tetrahedron *firstNewTetra = *startTetraItr;
		// scan the tetra list until you find a tetra with new ID
		if (firstNewTetra->GetID() < lowestNewId)
		{
			startTetraItr++;
			AppOutN(firstNewTetra->GetID());
		}
		else
		{
			break;
		}
	}

#ifdef _DEBUG_STRICT
	//assert( ((tetras.Last()-lastOldItr)/sizeof(TetraList::Itr)) == oldSize);
#endif
	
#ifdef _DEBUG_APPOUT1
		AppOut("********size of tetra list: ");
		AppOut(tetras.Size());
		AppEndl();
		AppOut("newTetraCount = ");
		AppOut(newTetraCount);
		AppEndl();
#endif

	int numLoops = 0;
	for (TetraList::Itr newTetraItr = startTetraItr; (newTetraItr != stopTetraItr)&&(newTetraCount-- > 0); newTetraItr++)
	{
		WireTetrahedron2(startTetraItr, stopTetraItr, newTetraItr);
#ifdef _DEBUG_APPOUT1
		numLoops++;
#endif
	}

#ifdef _DEBUG_APPOUT1
		//static int numLoops = 0;
	    AppOut("number of loops: ");
		AppOut(numLoops);
		AppEndl();
#endif 
	
	 
			

	//AppOut("aftger tetra creat ");
	//AppOutN((int)faces.size());

	//cout << "after tetra creatoin: " << faces.size() << endl; 
}



// ///////////////////////////////////////////////////////////
// function: CircumsphereIsIntersected()
//
// creation date:	22/11/00
// last modified:	11/12/00
// purpose: check interection between a sphere and a vertex point
//
// arguments: sphere's tetrahedron and vertex index
//            
// ///////////////////////////////////////////////////////////

int DelaunayTetrahedralizer::CircumsphereIsIntersected(Tetrahedron *tetra, int pointIndex)
{
	// TODO: finish implementation

	// ///////////////////////////
	Vertex3* point = &(Vertex3::GetGlobalVertexList()[pointIndex]);
	Vertex3 centerObject = tetra->Centre();
	Vertex3* center = &centerObject;

	// error checking: force to initilize vertex list's neighbors
#ifdef _DEBUG_ON
	assert(center->neigh != NULL);
#endif
	//AppOutN("CircumsphereIsIntersected: ");
	//AppOut("**center**, ");
	//center->Print();
	//AppOut(" **point**, ");
	//point->Print();
	//AppEndl();

	

	double squareDistance = SQUARE_DISTANCE3P(point, center);
	
	//AppOutMode(APPOUT_LOGFILE);
	//AppOut("original center"); tetra->Centre().Print();
	//AppOut("center      : "); centre->Print();
	//AppOut("point       : "); point->Print();
	//AppOut("sq Radius   : "); AppOutN(tetra->SquareRadius());
	//AppOut("sq Distance : "); AppOutN(squareDistance);
	//int inside = (int)(squareDistance < tetra->SquareRadius());
	//AppOut("INSIDE      : "); AppOutN(inside);
	//AppOutLn(10);

	// check if the point falls inside the sphere
	// keep into account round-off error due to the
	// surface thickness
	if ( fabs(squareDistance - tetra->SquareRadius()) < (abs(machineTollerance)+0.0000000))
	{
		/*
		AppOut("**************************\n");
		AppOut("**** POINT REJECTED ****");
		AppOut(pointIndex);
		AppOut(" - sq dist: ");
		AppOut(squareDistance);
		AppOut(" - sq radius ");
		AppOut(tetra->SquareRadius());
		AppEndl();
		AppOut("**************************\n");
		AppOut("************MT*****************\n");
		AppOut(machineTollerance);
		AppOut("**************************\n");
		AppOut("**************************\n");
		AppOut("**************************\n");
		AppOut("**************************\n");
		AppOut("**************************\n");	
		*/
		return DELAUNAY_CIRCUMSPHERE_REJECTED;
	}
	// if (squareDistance < (tetra->SquareRadius() - (10.0 / tetra->SquareRadius()) * CIRCUM_DELTA) )
	else if (squareDistance < tetra->SquareRadius())
	{
		return DELAUNAY_CIRCUMSPHERE_INTERSECTED;
	}
	else
	{
		return DELAUNAY_CIRCUMSPHERE_NOT_INTERSECTED;
	}
}

// ////////////////////////////////////////////////////////////////////////
// FlagTetrahedronForDeletion
// purpuse: flag a tetrahedron for deletion.
//
// note: FlagTetrahedronForDeletion is an helping function
// for the tetrahedron flag mechanism 

void DelaunayTetrahedralizer::FlagTetrahedronForDeletion(TetraList::Itr tetraItr)
{
	//AppOut("FlagTetrahedronForDeletion");
	//AppEndl();

	 (*tetraItr)->Flagged(true);
}



// ///////////////////////////////////////////////////////////
// function: DeleteFlaggedTetrahedra()
//
// creation date:	09/12/00
// last modified:	11/12/00
// purpose: delete flagged tetrahedra
//
// arguments: tetra list
//          
// ///////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::DeleteFlaggedTetrahedra(TetraList& tetraList, TetraList::Itr firstItr, TetraList::Itr lastItr, TetraList::Itr notFound)
{
	bool isFlagged = false;
	Tetrahedron* tetra;

	TetraList::Itr prev;
	// no tetrahedra were found to be deleted
	if (firstItr == notFound)
	{
		return;
	}

	do 
	{
	
	    tetra = *firstItr;
		
		if (tetra->IsFlagged())
		{
			tetra->EnableLocalFace(false);
			// deallocate teterahedron:
			delete tetra;

			// erase tetrahedron pointer from the list
			prev = firstItr;
			isFlagged = true;
			
			
		}

	    firstItr++;
		if (isFlagged)
		{
			tetraList.Erase(prev);
			isFlagged = false;
		}
	


	} while (firstItr != tetraList.End()/*lastItr*/);

    //AppOut("DELETE: ENDED.");
	//AppEndl();
}



// ///////////////////////////////////////////////////////////
// function: RestoreFlaggedTetrahedra()
//
// creation date:	09/12/00
// last modified:	11/12/00
// purpose: restore flagged tetrahedra
//
// arguments: iterators for tetraList range to check
//            
// ///////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::RestoreFlaggedTetrahedra(TetraList::Itr firstItr, TetraList::Itr lastItr, TetraList::Itr notFound)
{
	Tetrahedron* tetra;

	//AppOut("RestoreFlaggedTetrahedra");
	//AppEndl();

	assert(firstItr != notFound);
	// no tetrahedra were found to be deleted/restored
	if (firstItr == notFound)
	{
		//AppOut("RESTORE: TETRA NOT FOUND");
		//AppEndl();
		return;
	}

	//AppOut("RESTORE: UNWRAPPING tetrahedron");
	//AppEndl();
	do 
	{
		tetra = *firstItr;
		assert(tetra != NULL);
		if (tetra->IsFlagged())
		{
			tetra->Flagged(false);
		}

	} while (firstItr++ != lastItr);
}




// ///////////////////////////////////////////////////////////
// function: FlagAndDeleteBallSeededTetrahedra()
//
// creation date:	09/12/00
// last modified:	11/12/00
// purpose: flag and delete seeded tetrahedra
//
// arguments: tetra list, index to insertion vertex
//            
// ///////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::FlagAndDeleteBallSeededTetrahedra(TetraList &tetras, int pointIndex, list<Face3*> &temp)
{

	TetraList::Itr tetraStartItr = tetras.Begin();
	TetraList::Itr tetraStopItr = tetras.End();
	TetraList::Itr const firstFlaggedItr = tetraStartItr;
	TetraList::Itr lastFlaggedItr = tetraStartItr;

	int beforeTetraSize = (int)tetras.Size();
	int result;
	int listSize = tetras.Size();
	for (int i = 0; i < listSize; i++)
	{
		Tetrahedron *tetra = *tetraStartItr;
		result = CircumsphereIsIntersected(tetra, pointIndex);

		if (result == DELAUNAY_CIRCUMSPHERE_INTERSECTED)
		{
			temp.push_back(tetra->F(0));
			temp.push_back(tetra->F(1));
			temp.push_back(tetra->F(2));
			temp.push_back(tetra->F(3));

			// save iterator of last tetrahedron found so far 
			// and flag it
			lastFlaggedItr = tetraStartItr;
			tetra->Flagged(true);
		
			// reassign invalidated interators
		}
		else if (result == DELAUNAY_CIRCUMSPHERE_REJECTED)
		{
			while (!temp.empty())
			{
				temp.pop_back();
			}

			tetra->Flagged(false);
			RestoreFlaggedTetrahedra(firstFlaggedItr, lastFlaggedItr, tetraStopItr);
            assert( ((int)tetras.Size()+(int)temp.size()/4)==beforeTetraSize);

			return;
		}
		else
		{
			tetra->Flagged(false);
		}

		tetraStartItr++;
	}
	// end of for loop
	DeleteFlaggedTetrahedra(tetras, firstFlaggedItr, lastFlaggedItr, tetraStopItr);
	assert( ((int)tetras.Size()+(int)temp.size()/4)==beforeTetraSize);

}


// ///////////////////////////////////////////////////////////
// function: IsTetraTouchingSuperBoundary()
//
// creation date:	09/12/00
// last modified:	11/12/00
// purpose: check if tetrahedron lies outside the boundary
//          of the convex-hull
//
// arguments: tetrahedron
//            
// ///////////////////////////////////////////////////////////

bool DelaunayTetrahedralizer::IsTetraTouchingSuperBoundary(Tetrahedron *tetra, Vertex3* a[4])
{

	// check if any tetrahedron's face is between the 
	// boundary of the supertetrahedron and the boundary
	// of the actual Delaunay tetrahedrization

	bool t0, t1, t2;
	bool IsTouchingSuperVertices = false;
	Face3 *f;

	for (int i = 0; i < 4; i++)
	{
		// process  face
		f = tetra->F(i);
		t0 = VERTEX3_IS_EQUALP(a[0],f->V(0))||VERTEX3_IS_EQUALP(a[1],f->V(0))||VERTEX3_IS_EQUALP(a[2],f->V(0))||VERTEX3_IS_EQUALP(a[3],f->V(0));
		t1 = VERTEX3_IS_EQUALP(a[0],f->V(1))||VERTEX3_IS_EQUALP(a[1],f->V(1))||VERTEX3_IS_EQUALP(a[2],f->V(1))||VERTEX3_IS_EQUALP(a[3],f->V(1));
		t2 = VERTEX3_IS_EQUALP(a[0],f->V(2))||VERTEX3_IS_EQUALP(a[1],f->V(2))||VERTEX3_IS_EQUALP(a[2],f->V(2))||VERTEX3_IS_EQUALP(a[3],f->V(2));
		IsTouchingSuperVertices = t0||t1||t2;
		
		if (IsTouchingSuperVertices)
			return IsTouchingSuperVertices;
	}
	return IsTouchingSuperVertices;
}


// ///////////////////////////////////////////////////////////////
// DeleteArbitraryBoundaryFace:
//
// purpose: delete all tetrahedra and associated faces which
// lie on between the boudary of the supertetrahedron and 
// the outer boundary of the actual tetrahedrization
// 
// note: this function gives back the convex hull of the 
// original point set, by filtering out any face and simplices
// originated by the arbitrary vertices of the supertetrahedron
//

void DelaunayTetrahedralizer::DeleteArbitraryBoundaryFaces(TetraList &tetras)
{
	int arbitrary[4];		// array to hold indices to arbitrary points
	// the index to the last entry in the global vertex list is the last of 
	// the four vertices of the supertetrahedron. 
	int lastIndex = Vertex3::GetGlobalVertexCount()-1;

	Vertex3 *a[4];

	// get supertetrahedron vertices
	a[0] = Vertex3::GetGlobalVertexList() + (Vertex3::GetGlobalVertexCount()-4);
	a[1] = a[0] + 1;
	a[2] = a[0] + 2;
	a[3] = a[0] + 3;

	// save indices to supertetrahedron vertices
	for (int n = 3; n >= 0; n--)
	{
		arbitrary[n] = lastIndex--;
	}

	// scan the entire list of tetrahedra and find any 
	// that has a vertex index to the supertetrahedron
	TetraList::Itr start = tetras.Begin();
	TetraList::Itr end   = tetras.End();
	TetraList::Itr prev;

	int count = 0;
	for (; start != tetras.End(); )
	{
		// fecth the faces of the current tetrahedron
		Tetrahedron* tetra = *start;

		// if a tetrahedron is found then delete it from the 
		// global list of tetrahedra
		bool tetrahedronTouchingSuperBoundary = IsTetraTouchingSuperBoundary(tetra, &a[0]);

		if (tetrahedronTouchingSuperBoundary)
		{
			// delete actual tetrahedron first
			tetra->EnableLocalFace(true);
			delete tetra;
			prev = start;
		}
		
        start++;
		if (tetrahedronTouchingSuperBoundary)
		{
					// erease tetrahedron pointer from list second
			tetras.Erase(prev);
		}
	}
	
}



// ///////////////////////////////////////////////////////////
// function: Build()
//
// creation date:	10/02/01
// last modified:	10/02/01
// purpose: build the Delaunay tetrahedralization 
//
// arguments: tetralist is the list of all tetrahedra to be built
// ///////////////////////////////////////////////////////////

void DelaunayTetrahedralizer::Build(TetraList &tetraList)
{
	Tetrahedron *super;

	// PHASE1: build super tetrahedron
	super = CreateSuperTetrahedron(Vertex3::GetGlobalVertexList(), Vertex3::GetGlobalVertexCount());
	tetraList.Add(super);

#ifdef _DEBUG_STRICT
	int TETRALIST_SIZE_AFTER_SUPERTETRA_IS_NOT_POSITIVE = ((int)tetraList.Size()>0);
	assert(TETRALIST_SIZE_AFTER_SUPERTETRA_IS_NOT_POSITIVE);
#endif


	// PHASE2: insert all sample points into current tetrahedralization
	int maxPoints = Vertex3::GetGlobalVertexCount();

	for (int insertPoint = 0; insertPoint < maxPoints; insertPoint+=1)
	{
		// find ball-seeded tetrahedra
		list<Face3 *> tempFaceList;	
		
		FlagAndDeleteBallSeededTetrahedra(tetraList, insertPoint,  tempFaceList);	
		RetainSinglyOccurringFaces(tempFaceList);
		CreateTetrahedronFrom4FacesAndPoint(tempFaceList, insertPoint, tetraList);
    }


	// PHASE3: eliminate boundary tetrahedra and supertetrahedron
	DeleteArbitraryBoundaryFaces(tetraList);
	Vertex3::SetGlobalVertexCount( Vertex3::GetGlobalVertexCount()-4 );
}



// ///////////////////////////////////////////////////////////
// function: Build
//
// creation date:	07/02/01
// last modified:	07/02/01
// purpose: build the voronoi tessellation from the Delaunay tetrahedralization
//
// arguments: tetralist is the list of all existing tetrahedra
// 
// notes: exploit geometrical/memory coherence
// 

void VoronoiTessellator::Build(TetraList &tetraList)
{
	TetraList::Itr startIter;
	TetraList::Itr endIter;
	
	startIter = tetraList.Begin();
	endIter = tetraList.End();
	int faceCount = 4;

	for (; startIter != endIter; startIter++)
	{
		Tetrahedron *tetra = *startIter;
		FindNeighbouringFaces(tetraList, tetra);
	}	
}


// ///////////////////////////////////////////////////////////
// function: FindNeighbouringFaces()
//
// creation date:	11/02/01
// last modified:	11/02/01
// purpose: find faces that are neigbours
//
// arguments: tetralist is the list of all existing tetrahedra
// ///////////////////////////////////////////////////////////

void VoronoiTessellator::FindNeighbouringFaces(TetraList& tetraList, Tetrahedron* tetra)
{
	TetraList::Itr startIter;
	TetraList::Itr endIter;
	
	startIter = tetraList.Begin();
	endIter = tetraList.End();
	int faceCount = 4;
	int faceIndex;
	for (; (startIter != endIter) && (faceCount> 0); startIter++)
	{
		Tetrahedron *someTetra = *startIter;
		// do not wire a tetrahedron with itself!
		if (someTetra->GetID() != tetra->GetID())
		{
			faceIndex = 0;
			WireTwoNeighbouringTetrahedra(faceIndex, someTetra, tetra, faceCount);
			faceIndex = 1;
			WireTwoNeighbouringTetrahedra(faceIndex, someTetra, tetra, faceCount);
			faceIndex = 2;
			WireTwoNeighbouringTetrahedra(faceIndex, someTetra, tetra, faceCount);
			faceIndex = 3;
			WireTwoNeighbouringTetrahedra(faceIndex, someTetra, tetra, faceCount);
		}
	}
}


// ///////////////////////////////////////////////////////////
// function: WireTwoNeighbouringTetrahedra()
//
// creation date:	11/02/01
// last modified:	11/02/01
// purpose: wire two tetrahedra that share a face
//
// arguments: tetralist is the list of all existing tetrahedra
// ///////////////////////////////////////////////////////////

void VoronoiTessellator::WireTwoNeighbouringTetrahedra(int faceIndex, Tetrahedron* someTetra, Tetrahedron* tetra, int& faceCount)
{

		Face3 *someFace = someTetra->F(faceIndex);

		if (*someFace == *(tetra->F(0)))
		{
			faceCount--;
			someFace->neigh = tetra;
			tetra->F(0)->neigh = someTetra;
		}
		if (*someFace == *(tetra->F(1)))
		{
			faceCount--;
			someFace->neigh = tetra;
			tetra->F(1)->neigh = someTetra;
		}
		if (*someFace == *(tetra->F(2)))
		{
			faceCount--;
			someFace->neigh = tetra;
			tetra->F(2)->neigh = someTetra;
		}
		if (*someFace == *(tetra->F(3)))
		{
			faceCount--;
			someFace->neigh = tetra;
			tetra->F(3)->neigh = someTetra;
		}
}




// ///////////////////////////////////////////////////////////
// function: LinkVerticesToNeighTetrahedra()
//
// creation date:	11/02/01
// last modified:	11/02/01
// purpose: link each sample vertex to the tetrahedron that it touches
//
// arguments: tetralist is the list of all existing tetrahedra
// ///////////////////////////////////////////////////////////

void VoronoiTessellator::LinkVerticesToNeighTetrahedra(TetraList &tetraList)
{
	TetraList::Itr startIter;
	TetraList::Itr endIter;
	
	startIter = tetraList.Begin();
	endIter = tetraList.End();


	for (; startIter != endIter; startIter++)
	{
		// link a tetrahedron to all of its four vertices
		// follow the 0-0-0-2 convention for vertex location 
		// within a tetrahedron (see CreateTetrahedronFrom4FaceAndPoint())
		Tetrahedron *tetra = *startIter;
		Face3 *face = tetra->F(0);
		face->V(0)->neigh->Add(tetra);
		face->V(1)->neigh->Add(tetra);
		face->V(2)->neigh->Add(tetra);
		face = tetra->F(3);
		face->V(2)->neigh->Add(tetra);	

		// if a face is on the convexhull then propagate 
		// this information about boundary status from
		// tetrahedron's faces to vertices
		for (int i = 0; i < 4; i++)
		{
			face = tetra->F(i);
			if (IsFaceOnConvexHull(face))
			{
				face->V(0)->SetFlag(GEOM_ON_CONVEX_HULL);
				face->V(1)->SetFlag(GEOM_ON_CONVEX_HULL);
				face->V(2)->SetFlag(GEOM_ON_CONVEX_HULL);

				// establish if face is cw or ccw
				// note: actually by now each face should already
				// know its state, so this is a precaution
				if (face->GetFlag() == GEOM_UNKNOWN_STATE)
				{
					if (IsFaceClockWise(face, &face->normal))
					{
						face->SetFlag(GEOM_FACE_IS_CW);
					}
					else
					{
						face->SetFlag(GEOM_FACE_IS_NOT_CW);
					}
				}

				// orient faces in a clockwise way
				assert(face->GetFlag() != GEOM_UNKNOWN_STATE);
				if (face->GetFlag() == GEOM_FACE_IS_NOT_CW)
				{
					face->Flip();
					//AppOut("flipped face of thetrahedra ");
					//AppOut(tetra->GetID());
					//AppEndl();
				}
				
			}
			else
			{
				/*
				if(face->V(0)->GetFlag() != GEOM_ON_CONVEX_HULL)
				{
					face->V(0)->SetFlag(GEOM_NOT_ON_CONVEX_HULL);
				}
				if(face->V(1)->GetFlag() != GEOM_ON_CONVEX_HULL)
				{
					face->V(1)->SetFlag(GEOM_NOT_ON_CONVEX_HULL);
				}
				if(face->V(2)->GetFlag() != GEOM_ON_CONVEX_HULL)
				{
					face->V(2)->SetFlag(GEOM_NOT_ON_CONVEX_HULL);
				}
				*/
			}
		}
	}
}


// /////////////////////////////////////////////////
// geom.h
//
// author:			Aaron Licata
// creation date:	20/08/00
// last modified:	20/08/00
//
// Header file for all general geometrical data structures
// and procedures

#ifndef GEOM_H
#define GEOM_H

#include <assert.h>
#include <list>
#include "STL.h"
#include "math.h"
#include "appio.h"

// Constants
#define NO_LINK			0

// Macros
#define COPYVERTS(v0, v1) v0.x=v1.x;v0.y=v1.y;v0.z=v1.z
#define VERTEX3_IS_EQUALP(vl,vr) ((vl->x==vr->x)&&(vl->y==vr->y)&&(vl->z==vr->z))

// forward declarations
class Edge3;
class Face3;
class Tetrahedron;
class TetraList;

#define SET_VERTEX(obj,x,y,z) {obj.x=x;obj.y=y;obj.z=z;} 

// enumeration type for geometry status of tetrahedra, faces, vertices

/*enum GeometryStatus 
{ 
	GEOM_UKNOWN_STATE,
	GEOM_ON_CONVEX_HULL,
	GEOM_NOT_ON_CONVEX_HULL

} GSInstance;
*/

// general
const unsigned char GEOM_UNKNOWN_STATE = 0;
// vertex
const unsigned char GEOM_ON_CONVEX_HULL = 1;
const unsigned char GEOM_NOT_ON_CONVEX_HULL = 2;
// face
const unsigned char GEOM_FACE_IS_CW = 1;
const unsigned char GEOM_FACE_IS_NOT_CW = 2;


// ////////////////////////////////////////////////////////////////
// class Vertex3
//
// author:		Aaron Licata
// creation date:	30/08/00
// last modified:	22/04/01
//
// purpose: class representing a vertex in 3-d space with 
//          information about its direction normal and 
//          connectivity information to the neighbour tetrahedra 
// 
// /////////////////////////////////////////////////////////////////

class Vertex3
{
public:
	Vertex3();
	Vertex3(double a, double b, double c);
	~Vertex3();
	void SetVertex(double a, double b, double c) {x=a; y=b; z=c;}
	void SetVertex(Vertex3& v) { x=v.x; y=v.y; z=v.z; }
	void Print() { AppOut(x); AppOut(y), AppOut(z); AppEndl(); }
	void DeleteNeighborList();
	void InitNeighborList();
	void SetFlag(int status) { flag = status; }
	int GetFlag() { return flag; }
	bool IsPole() { return pole; }
	void SetPole(bool state) { pole = state; }
	Vector3 & Normal() { return normal; }
	static void SetGlobalVertexList(Vertex3* vertList) 
	{ 
		globalVertexList = vertList; 
	}
	static Vertex3* GetVertex(int vertexId) { return &globalVertexList[vertexId];}
	static Vertex3* GetGlobalVertexList() { return globalVertexList; }
	static void SetGlobalVertexCount(int count) { globalVertexCount = count; }
	static int GetGlobalVertexCount() { return globalVertexCount; }

	void CopyTo(Vertex3& dest);

public:
	double x,y,z;
	TetraList *neigh;
	unsigned char flag;
	bool pole;
	Vector3 normal;

private:
	static Vertex3* globalVertexList;
	static int globalVertexCount;

};

void InitNeighborList(Vertex3& v);  
void DeleteNeighborList(Vertex3& v); 


// forward declaration of Face3
class Face3;


// ////////////////////////////////////////////////////////////////
// class Edge3
//
// author:		Aaron Licata
// creation date:	30/09/00
// last modified:	22/04/01
//
// purpose: class representing a edge in 3-d space with 
// 
// /////////////////////////////////////////////////////////////////

class Edge3
{
public:
   
    Edge3() ;                   	//  default constructor
    Edge3( Edge3& );      		//  copy constructor
    Edge3(const int v0, const int v1);
    ~Edge3() ;                   	//  destructor

	void SetLocalVertexList(Vertex3* commonPool);
	Vertex3* GetLocalVertexList() { return vertexList; }
	Vertex3 *V(int i);
	void V(int i, Vertex3& value);
	void I(int i, int indexValue);
	int I(int i);

	void Print();
	void PrintV();

      Edge3& operator=( const Edge3& ) ;  //  assignment operator
	int IsEqual(Edge3& e2);

    friend int operator==( Edge3&, Edge3& ) ; //  equality operator
    friend int operator!=( Edge3&, Edge3& ) ; //  inequality operator

    int& operator[]( int i ) ;               // access to component vertices

public:
    int vert[2]; //  store the vertices as local copies 
	Vertex3 *vertexList;

} ;

int operator==( Edge3& l, Edge3& r);
int operator!=( Edge3& l, Edge3& r);



// ////////////////////////////////////////////////////////////////
// class Face3
//
// author:		Aaron Licata
// creation date:	30/09/00
// last modified:	22/04/01
//
// purpose: class representing a face in 3-d space 
// 
// /////////////////////////////////////////////////////////////////

class Face3
{
public:
   
    Face3() ;                    //  default constructor
    Face3( const Face3& );       //  copy constructor
	Face3(Edge3& e0, Edge3& e1, Edge3& e2); //  conversion constructor
	Face3(int i0, int i1, int i2);
	Face3(int i0, int i1, int i2, Vertex3 *commonPool);

    ~Face3() ;                   //  destructor

	void SetLocalVertexList(Vertex3* commonPool);
    Face3& operator=( const Face3& ) ;  //  assignment operator

    friend int operator==( const Face3&, const Face3& ) ; //  equality operator
    friend int operator!=( const Face3&, const Face3& ) ; //  inequality operator

	Vertex3 *V(int i);
	Edge3 * E(int i) { return &edge[i]; }
	int I(int i) { return edge[i].I(0); }
	void V(int i, Vertex3& v) { edge[i].V(0, v); edge[(i+1)%3].V(1, v);}
	void Flip(); 
	Vector3& Normal() { return normal; }
	void MakeNormal();
	bool IsClockWise(); 
	void SetFlag(unsigned char state) { flag = state; };
	unsigned char GetFlag() { return flag; };


	void Print();
	void PrintV();

    Edge3& operator[]( int i ) ;               // access to component edges - wise?

	void SetEdge(int i, Edge3& e) { edge[i] = e; MakeNormal();}
    
public:
    Edge3 edge[3] ;  //  store the edges as local copies 
public:
	Tetrahedron *neigh;
	Vector3 normal;
	unsigned char flag;
} ;

int operator==(Face3&,Face3& ) ; //  equality operator
int operator!=(Face3&,Face3& ) ; //  inequality operator

class Face3List
{
public:
	typedef list<Face3*>::iterator Itr;
	typedef list<Face3*> Type;
public:
	void Add(Face3* face) { faceList.push_back(face); }
	void RemoveLast() { faceList.pop_back(); }
	Face3* First() { return faceList.front();}
	Face3* Last() { return faceList.back(); }
	Itr Begin() { return faceList.begin(); }
	Itr End() { return faceList.end(); }
	int Size() { return faceList.size(); }
	void DeleteAll();
	
private:
	Type faceList; // global list of faces

};



// ////////////////////////////////////////////////////////////////
// class Tetrahedron
//
// author:		Aaron Licata
// creation date:	30/09/00
// last modified:	22/04/01
//
// purpose: class representing a tetrahedron
// 
// /////////////////////////////////////////////////////////////////

class Tetrahedron
{
public:
    Tetrahedron() ;                    //  default constructor
    Tetrahedron( const Tetrahedron& ); //  copy constructor
	Tetrahedron(Face3& f0, Face3& f1, Face3& f2, Face3& f3);
	Tetrahedron(Face3* f0, Face3* f1, Face3* f2, Face3* f3);

    ~Tetrahedron() ;                   //  destructor
	void Print();


    Tetrahedron& operator=( const Tetrahedron& ) ;  //  assignment operator

    friend int operator==( const Tetrahedron&, const Tetrahedron& ) ; //  equality operator
    friend int operator!=( const Tetrahedron&, const Tetrahedron& ) ; //  inequality operator

    Face3*& operator[]( int i ) ;               // access to component vertices
	Face3* F(int i);
	void InitializeTetra();
	void GetAllVerticesInOrder(Vertex3 *v);
	void CalculateCentreAndRadius();
	void EnableLocalFace(bool mode) { localCopy = mode; }
	void SetLocalVertexList(Vertex3* commonPool);
	int AllocFace(int i);
	void Flagged(bool status) { flagged = status; }
	bool IsFlagged() { return flagged; }
	//void SetFace(int i, Edge3&, Edge3&, Edge3&);
	void InitNeighbours();
	void Drawn(bool state) { drawn = state; }
	bool AlreadyDrawn() { return drawn; }
	int GetID() { return id; }
	Vertex3& Centre() { return center; }
	Vertex3* GetCentre() { return &center; }
	double SquareRadius(){ return squareRadius;}
	static int GetCurrentID() { return currentId; }
private:
	static void SetCurrentID(int i) { currentId = i; }

private:
	Face3* face[4];
	bool localCopy;
	Vertex3 center;			// Voronoi vertex (tetra center)
	double squareRadius;    // square radius from center
	bool flagged;			
	int id;					// id of this tetrahedron
	static int currentId;	// global id generated by Tetrahedron class for next Tetrahedron object
	bool drawn;
	
	
};


// ////////////////////////////////////////////////////////////////
// class TetraList
//
// author:		Aaron Licata
// creation date:	30/09/00
// last modified:	22/04/01
//
// purpose: class representing a list of tetrahedron
// 
// /////////////////////////////////////////////////////////////////

class TetraList
{
public:
	typedef list<Tetrahedron*>::iterator Itr;
	typedef list<Tetrahedron*>::reverse_iterator RevItr;
    typedef list<Tetrahedron*> Type;
public:
	TetraList() {};
	~TetraList() { DeleteAll(); }    


	Type& GetList() { return tetraList; }
	void Add(Tetrahedron* t) { tetraList.push_back(t); }
	Itr Begin() { return tetraList.begin(); }
	RevItr Rbegin() { return tetraList.rbegin(); }
	RevItr Rend() { return tetraList.rend(); }
	Itr End() { return tetraList.end(); }
	Tetrahedron* Last() { return tetraList.back(); }
	void PopBack() { tetraList.pop_back(); }
	Tetrahedron* First() { return tetraList.front(); }
	int Size() { return tetraList.size(); }
	void Erase(Itr &i) {tetraList.erase(i); }
	int Empty() { return tetraList.empty(); }
	void DeleteAll();
	void Delete(Itr &i); 

// data members
private:
	Type tetraList; // global list of tetrahedra

};



// ////////////////////////////////////////////////////////////////
// class SuperTetra
//
// author:			Aaron Licata
// creation date:	30/08/00
// last modified:	22/04/01
//
// purpose: class representing a very large tetrahedron (super)
// 
// /////////////////////////////////////////////////////////////////

class SuperTetra
{
public:
	SuperTetra();
    void Set(Vertex3, Vertex3, Vertex3, Vertex3);
	Vertex3& GetApex() { return vApex; }
	Vertex3& GetBaseLeft() { return vBaseLeft; }
	Vertex3& GetBaseRight() { return vBaseRight; }
	Vertex3& GetBaseBack() { return vBaseBack; }
	void SetSuperFactor(int factor) { superFactor = factor; }
	int GetSuperFactor() { return superFactor ; }



public:
	Vertex3 vApex;
	Vertex3 vBaseLeft;
	Vertex3 vBaseRight;
	Vertex3 vBaseBack;
	int superFactor;
};



/*
class TetraListItr
{
public:

public:
	TetraList::Itr i;
};
*/



class Mesh
{
public:
	Vertex3 *vertData;
	int vertCount;
	Face3 *tri;
	int triCount;
};

class Skeleton
{
public:
	// geometry 
	Vertex3 * vert;
	int vertCount;

	// low-level topology
	Edge3 * edge;
	int edgeCount;

	Face3 * face;
	unsigned long * faceIndex;
	unsigned int faceCount;


	// non-manifold
	Tetrahedron * tetra;
	int tetraCount;

	// non-manifold
	Mesh * mesh;
	int meshCount;

public:
	Skeleton();
	~Skeleton();
};


#endif


// ////////////////////////////////////////////////////////////////
// geom.cpp
//
// author:			Aaron Licata
// creation date:	20/08/00
// last modified:	01/09/00
//
// Implementation file for all general geometrical data structures
// and procedures
// ////////////////////////////////////////////////////////////////

#include <assert.h>
#include "apperr.h"
#include "appio.h"
#include "math.h"
#include "ccenter.h"
#include "geomutil.h"
#include "geom.h"




Vertex3* Vertex3::globalVertexList = NO_LINK;
int Tetrahedron::currentId = 0;




// ///////////////////////////////////////////////////////////
// function: Vertex3 defualt constructor
//
// creation date:	20/08/00
// last modified:	10/10/00
// purpose: constructor
//
// // ///////////////////////////////////////////////////////////

Vertex3::Vertex3() 
{ 
	x = y = z = 0.0;
	neigh = new TetraList; 
	flag = GEOM_UNKNOWN_STATE;
	pole = false;
}


// ///////////////////////////////////////////////////////////
// function: Vertex3  constructor
//
// creation date:	20/08/00
// last modified:	10/10/00
// purpose: constructor
//
// // ///////////////////////////////////////////////////////////

Vertex3::Vertex3(double a, double b, double c) 
{ 
	x=a; y=b; z=c; 
	neigh = new TetraList;
	flag = GEOM_UNKNOWN_STATE;
	pole = false;
}



// ///////////////////////////////////////////////////////////
// function: ~Vertex3 destructor
//
// creation date:	20/08/00
// last modified:	10/10/00
//
// purpose: destructor
//
// // ///////////////////////////////////////////////////////////

Vertex3::~Vertex3() 
{
	
	if (neigh->Size() > 0) 
	{
		while (neigh->Size() > 0)
		{
			neigh->PopBack();
		}
		delete neigh;
	}
}



// ///////////////////////////////////////////////////////////
// function: CopyTo()
//
// creation date:	17/04/01
// last modified:	17/04/01
// purpose: copy the contents of one vertex into another
//
// arguments: reference to the destination vertex
// ///////////////////////////////////////////////////////////

void Vertex3::CopyTo(Vertex3& dest)
{
	double x,y,z;

	dest.x = x;
	dest.y = y;
	dest.z = z;

	dest.neigh = neigh;
	dest.flag = flag;
	dest.pole = pole;
	dest.normal.Set(normal);
}


int Vertex3::globalVertexCount = 0;


void Vertex3::InitNeighborList()
{ 

}

void Vertex3::DeleteNeighborList() 
{  
//	if (neigh) delete neigh;
}




// ////////////////////////////////////////////////////////////////////////
// Edge3 member functions

// ///////////////////////////////////////////////////////////
// function: Edge3()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: default constructor
//
// ///////////////////////////////////////////////////////////
Edge3::Edge3()
{
	SetLocalVertexList(Vertex3::GetGlobalVertexList());
	vert[0] = NO_LINK;
	vert[1] = NO_LINK;
}


// ///////////////////////////////////////////////////////////
// function: Edge3()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: copy  constructor
//
// arguments: edge to be copied
// ///////////////////////////////////////////////////////////

Edge3::Edge3( Edge3& edge)
{
	// copy the pointer to the vertex list of the source
	// edge as well
	SetLocalVertexList(edge.GetLocalVertexList());
	vert[0] = edge.vert[0];
	vert[1] = edge.vert[1];
}



// ///////////////////////////////////////////////////////////
// function: Edge3()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: copy  constructor
//
// arguments: edge to be copied
// ///////////////////////////////////////////////////////////

Edge3::Edge3(const int i0, const int i1) 
{ 
	SetLocalVertexList(Vertex3::GetGlobalVertexList());
	vert[0]=i0; 
	vert[1]=i1; 
}



// ///////////////////////////////////////////////////////////
// function: ~Edge3()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: destructor
//
// ///////////////////////////////////////////////////////////

Edge3::~Edge3()                
{
	
}  



// ///////////////////////////////////////////////////////////
// function: V()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: return pointer to an edge vertex
//
// arguments: index of vertex
// ///////////////////////////////////////////////////////////

Vertex3 *Edge3::V(int i) 
{ 
	assert(i<2&&i>=0);
	return &vertexList[vert[i]]; 
}



// ///////////////////////////////////////////////////////////
// function: V()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: return pointer to an edge vertex
//
// arguments: index of vertex
//
// return value: none
// ///////////////////////////////////////////////////////////

void Edge3::V(int i, Vertex3& value) 
{ 
	assert(i<2&&i>=0);
	vertexList[vert[i]].x = value.x;
	vertexList[vert[i]].y = value.y;
	vertexList[vert[i]].z = value.z;
}




// ///////////////////////////////////////////////////////////
// function: I()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: return index to an edge vertex
//
// arguments: edge's end vertex
//
// return value: none
// ///////////////////////////////////////////////////////////

void Edge3::I(int i, int indexValue) 
{
	assert(i<2&&i>=0); 
	vert[i] = indexValue; 
}



// ///////////////////////////////////////////////////////////
// function: I()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: return index to an edge vertex
//
// arguments: edge's end vertex
//
// return value: none
// ///////////////////////////////////////////////////////////

int Edge3::I(int i) 
{
	assert((i<2)&&(i>=0)); 
	return vert[i]; 
}




// ///////////////////////////////////////////////////////////
// function: Print()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: print value of an edge
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Edge3::Print()
{
	AppOut("-EDGE- ");
	AppOut("I0:"); AppOut(I(0)); AppOut(" I1:"); AppOut(I(1));
	AppEndl();
}


// ///////////////////////////////////////////////////////////
// function: PrintV()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: print value of an edge
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Edge3::PrintV()
{
	AppOutN("- EDGE-:");
	AppOut("I0 "); AppOutN(I(0));
	AppOut("I1 "); AppOutN(I(1));
	Vertex3 *v;
	v = V(0);
	AppOut("V0 "); AppOut(v->x); AppOut(v->y); AppOutN(v->z);
	v = V(1);
	AppOut("V1 "); AppOut(v->x); AppOut(v->y); AppOutN(v->z);
}



// ///////////////////////////////////////////////////////////
// function: operator=
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: overload operator =
//
// arguments: edge to be copied
//
// return value: edge reference
// ///////////////////////////////////////////////////////////

Edge3& Edge3::operator=( const Edge3& edge)       //  assignment operator
{
	if (this == &edge)
		return *this;
	vert[0] = edge.vert[0];
	vert[1] = edge.vert[1];

	return *this;
}



// ///////////////////////////////////////////////////////////
// function: operator=
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: set pointer to vertex list
//
// arguments: vertex list
//
// return value: none
// ///////////////////////////////////////////////////////////

void Edge3::SetLocalVertexList(Vertex3* commonPool)
{
	vertexList = commonPool;
}



// ///////////////////////////////////////////////////////////
// function: operator[]
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: overload operator[]
// arguments: vertex index
//
// return value: none
// ///////////////////////////////////////////////////////////

int& Edge3::operator[]( int i )                // access to component character - wise?
{
	assert(i >= 0 && i < 2);
	return vert[i];
}



// ///////////////////////////////////////////////////////////
// function: IsEqual()
//
// creation date:	11/01/01
// last modified:	11/01/01
// purpose: compare two edges
// arguments: edge to be compared
//
// return value: result of comparison
// ///////////////////////////////////////////////////////////

int Edge3::IsEqual(Edge3& r)
{
	Edge3& l = (*this);

	return (((l.vert[0]==r.vert[0]) && (l.vert[1]==r.vert[1]))) ||
		(((l.vert[0]==r.vert[1]) && (l.vert[1]==r.vert[0])));
}



// ////////////////////////////////////////////////////////////////////////
// global functions related to class Edge3
//

int operator==(Edge3& l, Edge3& r)  //  equality operator
{
	return (((l.vert[0]==r.vert[0]) && (l.vert[1]==r.vert[1]))) ||
		(((l.vert[0]==r.vert[1]) && (l.vert[1]==r.vert[0])));
}

int operator!=( Edge3& l, Edge3& r)  //  inequality operator
{
	return ((l.vert[0]!=r.vert[0]) || (l.vert[0]!=r.vert[1])) ;
}




// ///////////////////////////////////////////////////////////
// function: default constructor
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: default constructor
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

Face3::Face3()
{
	// Edge3 defult constructor called automatically
	neigh = NO_LINK;
	flag = GEOM_UNKNOWN_STATE;
}




// ///////////////////////////////////////////////////////////
// function: copyt constructor
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: copy constructor
// arguments: face to be copied
//
// return value: none
// ///////////////////////////////////////////////////////////

Face3::Face3( const Face3& face)
{
	edge[0] = face.edge[0];
	edge[1] = face.edge[1];
	edge[2] = face.edge[2];
	neigh = NO_LINK;
	MakeNormal();
	flag = GEOM_UNKNOWN_STATE;
}

// ///////////////////////////////////////////////////////////
// function: Face3()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: constructor
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

Face3::Face3(Edge3& e0, Edge3& e1, Edge3& e2)
{
	edge[0] = e0;
	edge[1] = e1;
	edge[2] = e2;
	neigh = NO_LINK;
	MakeNormal();
	flag = GEOM_UNKNOWN_STATE;
}




// ///////////////////////////////////////////////////////////
// function: Face3()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: conversion constructor
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

Face3::Face3(int i0, int i1, int i2)
{
	edge[0] = Edge3(i0, i1);
	edge[1] = Edge3(i1, i2);
	edge[2] = Edge3(i2, i0);
	neigh = NO_LINK;
	MakeNormal();
	flag = GEOM_UNKNOWN_STATE;
}



// ///////////////////////////////////////////////////////////
// function: Face3()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: conversion constructor
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

Face3::Face3(int i0, int i1, int i2, Vertex3 *commonPool)
{
	edge[0] = Edge3(i0, i1);
	edge[1] = Edge3(i1, i2);
	edge[2] = Edge3(i2, i0);

	edge[0].SetLocalVertexList(commonPool);
	edge[1].SetLocalVertexList(commonPool);
	edge[2].SetLocalVertexList(commonPool);
	neigh = NO_LINK;
	MakeNormal();
	flag = GEOM_UNKNOWN_STATE;
}




// ///////////////////////////////////////////////////////////
// function: SetLocalVertexList()
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: specify the vertex list
// arguments: vertex list
//
// return value: none
// ///////////////////////////////////////////////////////////

void Face3::SetLocalVertexList(Vertex3* commonPool)
{
	edge[0].SetLocalVertexList(commonPool);
	edge[1].SetLocalVertexList(commonPool);
	edge[2].SetLocalVertexList(commonPool);
}



// ///////////////////////////////////////////////////////////
// function: destructor
//
// creation date:	11/09/00
// last modified:	11/09/00
// purpose: destructor
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

Face3::~Face3()                
{
	
}  




// ///////////////////////////////////////////////////////////
// function: Flip()
//
// creation date:	06/03/01
// last modified:	06/03/01
// purpose: flip last two edges of a face; the effect is to 
//			convert a face from ccw to cw or viceversa
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Face3::Flip() 
{ 
	Edge3 tmp = edge[1]; 
	edge[1] = edge[2]; 
	edge[2] = tmp; 
	MakeNormal();
}



// ///////////////////////////////////////////////////////////
// function: MakeNormal()
//
// creation date:	17/02/01
// last modified:	06/03/01
// purpose: calculate the normal (perpendiacular) vector to this face
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Face3::MakeNormal()
{
	// prepare the components of two vectors from three vertices of face
	double x1 = this->V(0)->x - this->V(1)->x;
	double y1 = this->V(0)->y - this->V(1)->y;
	double z1 = this->V(0)->z - this->V(1)->z;

	double x2 = this->V(0)->x - this->V(2)->x;
	double y2 = this->V(0)->y - this->V(2)->y;
	double z2 = this->V(0)->z - this->V(2)->z;

	// vector product of two vectors is the normal to the face
	Vector3 v1(x1, y1, z1);
	Vector3 v2(x2, y2, z2);
	CrossProduct3(v1, v2, normal);
}



// ///////////////////////////////////////////////////////////
// function: IsClockWise()
//
// creation date:	06/03/01
// last modified:	06/03/01
// purpose: wrapper function to establish whether a face in 3-d 
//          is clockwise or counterclockwise. 
//
// arguments: none
//
// return value: boolean true if cw, false if ccw
// ///////////////////////////////////////////////////////////

bool Face3::IsClockWise()
{
	if (GetFlag() == GEOM_UNKNOWN_STATE)
	{

		if (IsFaceClockWise(this, &normal))
		{
			SetFlag(GEOM_FACE_IS_CW);
		}
		else
		{
			SetFlag(GEOM_FACE_IS_NOT_CW);
		}
	}
	
	return (GetFlag() == GEOM_FACE_IS_CW);
	
}

	

// ///////////////////////////////////////////////////////////
// function: operator=
//
// creation date:	06/03/01
// last modified:	06/03/01
// purpose: assigment operator
//      
// arguments: face to be copied
//
// return value: face reference
// ///////////////////////////////////////////////////////////

Face3& Face3::operator=( const Face3& f)       //  assignment operator
{
	if (this == &f)
		return *this;
	edge[0] = f.edge[0];
	edge[1] = f.edge[1];
	edge[2] = f.edge[2];

	normal.Set(f.normal.x, f.normal.y, f.normal.z);
	return *this;
}
 


// ///////////////////////////////////////////////////////////
// function: Print()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: print content of face
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Face3::Print()
{
	AppOut("*FACE*:");
    AppEndl();
	AppOut("  E0 ");  edge[0].Print();
	AppOut("  E1 ");  edge[1].Print();
	AppOut("  E2 ");  edge[2].Print();
}



// ///////////////////////////////////////////////////////////
// function: Print()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: print content of face
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Face3::PrintV()
{
	AppOutN("-FACE-:");
	AppOut("E0 ");  edge[0].PrintV();
	AppOut("E1 "); edge[1].PrintV();
	AppOut("E2 ");  edge[2].PrintV();
}



// ///////////////////////////////////////////////////////////
// function: operator[]
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: access operator
//      
// arguments: edge index 
//
// return value: edge reference
// ///////////////////////////////////////////////////////////

Edge3& Face3::operator[]( int i )                // access to component character - wise?
{
	assert(i >= 0 && i < 3);
	return edge[i];
}



// ///////////////////////////////////////////////////////////
// function: V()
//
// creation date:	02/09/00
// last modified:	11/02/01
// purpose: returns a pointer to a face vertex
//
// arguments: index of the required vertex
// ///////////////////////////////////////////////////////////

Vertex3 *Face3::V(int i) 
{
////////////////////////ASSERTIONS///////////////////////
#ifndef _DEBUG_STRICT
	assert(i >= 0 && i <= 2);
#endif
//////////////////////////////////////////////////////////

	return edge[i].V(0); 
}



// ////////////////////////////////////////////////////////////////////////
// global functions related to class Face3
//

// ///////////////////////////////////////////////////////////
// function: equality operator
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: compare faces
//      
// arguments: faces to compare
//
// return value: result of comparison
// ///////////////////////////////////////////////////////////

int operator==(Face3& l, Face3& r)  //  equality operator
{
	// Case 1
	//     L0==R0
        //     |    |     
	// L1==R1  L1==R2
	//    |      |
	// L2==R2  L2==R1
	if ( l.edge[0].IsEqual(r.edge[0]) )
	{
		if (l.edge[1].IsEqual(r.edge[1]))
		{
			if (l.edge[2].IsEqual(r.edge[2]))
			{
				return 1;
			}
		}
		else if (l.edge[1].IsEqual(r.edge[2]))
		{
			if (l.edge[2].IsEqual(r.edge[1]))
			{
				return 1;
			}
		}
	}

	// Case 2
	//     L0==R1
	//     |    |
	// L1==R0  L1==R2
	//    |      |
	// L2==R2  L2==R0
	if (l.edge[0].IsEqual(r.edge[1]))
	{
		if (l.edge[1].IsEqual(r.edge[0]))
		{
			if (l.edge[2].IsEqual(r.edge[2]))
			{
				return 1;
			}
		}
		else if (l.edge[1].IsEqual(r.edge[2]))
		{
				if (l.edge[2].IsEqual(r.edge[0]))
				{
					return 1;
				}
		}
	}

	// Case 3
	//     L0==R2
	//     |    |
	// L1==R0  L1==R0
	//    |      |
	// L2==R1  L2==R0
	if (l.edge[0].IsEqual(r.edge[2]))
	{
		if (l.edge[1].IsEqual(r.edge[0]))
		{
			if (l.edge[2].IsEqual(r.edge[1]))
			{
				return 1;
			}
		}
		else if (l.edge[1].IsEqual(r.edge[0]))
		{
				if (l.edge[2].IsEqual(r.edge[0]))
				{
					return 1;
				}
		}
	}

	return 0;
}


// ///////////////////////////////////////////////////////////
// function: disequality operator
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: compare faces
//      
// arguments: faces to compare
//
// return value: result of comparison
// ///////////////////////////////////////////////////////////

int operator!=(Face3& l, Face3& r)  //  inequality operator
{
	return !(l == r);
}



// ///////////////////////////////////////////////////////////
// function: Tetrahedron()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: default constructor
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

Tetrahedron::Tetrahedron()
{	
	face[0] = NO_LINK;
	face[1] = NO_LINK;
	face[2] = NO_LINK;
	face[3] = NO_LINK;
	InitializeTetra();
}



// ///////////////////////////////////////////////////////////
// function: Tetrahedron()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: copy constructor
//      
// arguments: tetrahedron
//
// return value: none
// ///////////////////////////////////////////////////////////

Tetrahedron::Tetrahedron( const Tetrahedron& tetra)
{
	// allocate new identical faces for this Tetrahedron
	face[0] = new Face3(*(tetra.face[0]));
	face[1] = new Face3(*(tetra.face[1]));
	face[2] = new Face3(*(tetra.face[2]));
	face[3] = new Face3(*(tetra.face[3]));
	face[0]->neigh = tetra.face[0]->neigh;
	face[1]->neigh = tetra.face[1]->neigh;
	face[2]->neigh = tetra.face[2]->neigh;
	face[3]->neigh = tetra.face[3]->neigh;

	// are these pointers to a global face list?
	// or are they local to this object
	localCopy = true;
	InitializeTetra();

	COPYVERTS(center, tetra.center);
	squareRadius = tetra.squareRadius;
	CalculateCentreAndRadius();

}



// ///////////////////////////////////////////////////////////
// function: Tetrahedron()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: conversion constructor
//      
// arguments: faces
//
// return value: none
// ///////////////////////////////////////////////////////////

Tetrahedron::Tetrahedron(Face3& f0, Face3& f1, Face3& f2, Face3& f3)
{
	// save face pointers in the private face list
	face[0] = new Face3(f0);
	face[1] = new Face3(f1);
	face[2] = new Face3(f2);
	face[3] = new Face3(f3);
    //InitNeighbours();

	// are these pointers to a global face list?
	// or are they local to this object
	localCopy = true;
	InitializeTetra();
	CalculateCentreAndRadius();
}



// ///////////////////////////////////////////////////////////
// function: Tetrahedron()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: conversion constructor
//      
// arguments: faces
//
// return value: none
// ///////////////////////////////////////////////////////////

Tetrahedron::Tetrahedron(Face3* f0, Face3* f1, Face3* f2, Face3* f3)
{
	// just copy the links to the already allocated Face3 object
	face[0] = f0;
	face[1] = f1;
	face[2] = f2;
	face[3] = f3;
    //InitNeighbours();

	// are these pointers to a global face list?
	// or are they local to this object
	localCopy = true;
	InitializeTetra();
	CalculateCentreAndRadius();
}



// ///////////////////////////////////////////////////////////
// function: ~Tetrahedron()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: destructor
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

Tetrahedron::~Tetrahedron()                
{
	assert(face[0] && face[1] && face[2] && face[3]);

	if (localCopy)
	{
		delete face[0];
		delete face[1];
		delete face[2];
		delete face[3];
	}
}  



// ///////////////////////////////////////////////////////////
// function: InitializeTetra()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: initialize a tetrahedron
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Tetrahedron::InitializeTetra()
{
	id = Tetrahedron::GetCurrentID();
	Tetrahedron::SetCurrentID(id+1);

	SetLocalVertexList(Vertex3::GetGlobalVertexList());
	flagged = false;
	drawn = false;
}




// ///////////////////////////////////////////////////////////
// function: CalculateCentreAndRadius()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: calcualate center and radius of a tetrahedron
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Tetrahedron::CalculateCentreAndRadius()
{
	double a[3];
	double b[3];
	double c[3];
	double d[3];

	Vertex3 p0, p1, p2, p3;

	SetLocalVertexList(Vertex3::GetGlobalVertexList());
	// TODO: change code to use GetAllVerticesInOrder()
	// like
	// Vertex3 p[4];
	// GetAllVerticesInOrder(p)
	COPYVERTS(p0,(*(F(0)->V(0))));
	COPYVERTS(p1,(*(F(0)->V(1))));
	COPYVERTS(p2,(*(F(0)->V(2))));
	COPYVERTS(p3,(*(F(3)->V(2))));

	a[0] = p0.x; a[1] = p0.y; a[2] = p0.z;
    b[0] = p1.x; b[1] = p1.y; b[2] = p1.z;
	c[0] = p2.x; c[1] = p2.y; c[2] = p2.z;
	d[0] = p3.x; d[1] = p3.y; d[2] = p3.z;

	double xi1[3];
	double xi2[3];
	double xi3[3];
	double cc[3];

	TetraCircumCenter(a, b, c, d, cc, xi1, xi2, xi3);

	center.x = cc[0] + a[0];
	center.y = cc[1] + a[1];
	center.z = cc[2] + a[2];

	squareRadius = SQUARE_DISTANCE3(center, p0);
}


// ///////////////////////////////////////////////////////////
// function: InitNeighbours()
//
// creation date:	30/09/00
// last modified:	30/09/00
// purpose: initialize neighbour
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Tetrahedron::InitNeighbours()
{
	face[0] = NO_LINK;
	face[1] = NO_LINK;
	face[2] = NO_LINK;
	face[3] = NO_LINK;

}



// ///////////////////////////////////////////////////////////
// function: Print()
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: print content of tetrahedron
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void Tetrahedron::Print()
{
	AppOut(".TETRAHEDON............................................."); 
	AppEndl();
	AppOut(" F0 "); face[0]->Print();
	AppOut(" F1 "); face[1]->Print();
	AppOut(" F2 "); face[2]->Print();
	AppOut(" F3 "); face[3]->Print();

}



// ///////////////////////////////////////////////////////////
// function: operator=
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: operator=
//      
// arguments: tetrahedron
//
// return value: tetrahedron reference
// ///////////////////////////////////////////////////////////

Tetrahedron& Tetrahedron::operator=( const Tetrahedron& tetra)       //  assignment operator
{
	if (this == &tetra)
		return *this;

	// delete current four faces
	assert(face[0] && face[1] && face[2] && face[3]);
		delete face[0];
		delete face[1];
		delete face[2];
		delete face[3];

	// copy four faces from some tetrahedron to this one
	// use pointers to faces of source tetrahedron as 
	// source of information
	face[0] = new Face3(*tetra.face[0]);
	face[1] = new Face3(*tetra.face[1]);
	face[2] = new Face3(*tetra.face[2]);
	face[3] = new Face3(*tetra.face[3]);

	return *this;
}


// ///////////////////////////////////////////////////////////
// function: operator[]
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: operator[]
//      
// arguments: index to faces
//
// return value: face pointer reference
// ///////////////////////////////////////////////////////////

Face3*& Tetrahedron::operator[]( int i )                // access to component character - wise?
{
	assert(i >= 0 && i < 4);
	return face[i];
}



// ///////////////////////////////////////////////////////////
// function: face index
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: face index
//      
// arguments: index to faces
//
// return value: face pointer reference
// ///////////////////////////////////////////////////////////

Face3* Tetrahedron::F( int i )                // access to component character - wise?
{
	assert(i >= 0 && i < 4);
	return face[i];
}



// ///////////////////////////////////////////////////////////
// function: GetAllVerticesInOrder()
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: get all vertices in order
//      
// arguments: pointer to vertex
//
// return value: none
// ///////////////////////////////////////////////////////////

void Tetrahedron::GetAllVerticesInOrder(Vertex3 *v)
{
	// get the four vertices of tetra in right order
	// so, to avoid confusion and bugs
	// TODO: implement

}



// ///////////////////////////////////////////////////////////
// function: SetLocalVertexList()
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: specify vertex list
//      
// arguments: pointer to vertex list
//
// return value: none
// ///////////////////////////////////////////////////////////

void Tetrahedron::SetLocalVertexList(Vertex3* commonPool)
{
	face[0]->SetLocalVertexList(commonPool);
	face[1]->SetLocalVertexList(commonPool);
	face[2]->SetLocalVertexList(commonPool);
	face[3]->SetLocalVertexList(commonPool);
}



// ///////////////////////////////////////////////////////////
// function: AllocFacet()
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: allocate face
//      
// arguments: index 
//
// return value: allocation result
// ///////////////////////////////////////////////////////////

int Tetrahedron::AllocFace(int i)
{
	face[i] = new Face3;
	if (!face[i])
	{
		AppError(APPERR_FACE_ALLOC);
		return 0;
	}

	return 1;
}

/*
void Tetrahedron::SetFace(int i, Edge3& e1, Edge3& e2, Edge3& e3)
{
	face[i]->SetEdge(0, e1);
	face[i]->SetEdge(1, e2);
	face[i]->SetEdge(2, e3);
}
*/
// ////////////////////////////////////////////////////////////////////////
// global functions related to class Tetrahedron
 //


// ///////////////////////////////////////////////////////////
// function: operator==
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: operator==
//      
// arguments: tetrahedra
//
// return value: none
// ///////////////////////////////////////////////////////////

int operator==( const Tetrahedron& l, const Tetrahedron& r)  //  equality operator
{
	// TODO
	return 1;
}



// ///////////////////////////////////////////////////////////
// function: inequality operator
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: inequality operator
//      
// arguments: tetrahedra
//
// return value: none
// ///////////////////////////////////////////////////////////

int operator!=( const Tetrahedron& l, const Tetrahedron& r)  //  inequality operator
{
	return 0;
}




// ///////////////////////////////////////////////////////
// FaceList
//
// ///////////////////////////////////////////////////////
// FaceListDeleteAll()
// purpose: delete all objects pointed to by and 
// the nodes of the list
void Face3List::DeleteAll()
{
	Itr start = faceList.begin();
	Itr end   = faceList.end();
    Itr tmp;

	while (start != end)
	{
		tmp = start;
		assert(start != end);
		start++;
		
		static int count = 0;
		AppOut("count: "); 
		AppOut(count++);
		AppEndl();
		// delete object and then its node
		assert(*tmp != NULL);
		delete *tmp;
		assert(tmp != NULL);
		faceList.erase(tmp);
	}
}


// ////////////////////////////////////////////////////////
// TetraList
//




// ///////////////////////////////////////////////////////////
// function: DeleteAll()
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: delete all tetrahedra in list
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void TetraList::DeleteAll()
{
	Itr start = tetraList.begin();
	Itr end   = tetraList.end();
    Itr tmp;

	while (start != end)
	{
		tmp = start;
		assert(start != end);
		start++;

		// delete object and then its node
		delete *tmp;
		tetraList.erase(tmp);
	}
}




// ///////////////////////////////////////////////////////////
// function: Delete()
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: delete tetrahedra in list
//      
// arguments: iterator to tetrahedron
//
// return value: none
// ///////////////////////////////////////////////////////////

void TetraList::Delete(Itr &i) 
{
	assert(*i != NULL);

	delete *i;
	tetraList.erase(i);
}




// ///////////////////////////////////////////////////////////
// function: SuperTetra()
//
// creation date:	10/10/00
// last modified:	10/10/00
// purpose: constructor
//      
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

SuperTetra::SuperTetra()
{
	vApex.SetVertex(0.0, 0.0, 0.0);
	vBaseLeft.SetVertex(0.0, 0.0, 0.0);
	vBaseRight.SetVertex(0.0, 0.0, 0.0);
	vBaseBack.SetVertex(0.0, 0.0, 0.0);

	superFactor = 2;
}




// ///////////////////////////////////////////////////////////
// function: Set()
//
// creation date:	10/02/01
// last modified:	10/02/01
// purpose: delete tetrahedra in list
//      
// arguments: vertices of the super pyramid
//
// return value: none
// ///////////////////////////////////////////////////////////

void SuperTetra::Set(Vertex3 apex, Vertex3 bLeft, Vertex3 bRight, Vertex3 bBack)
{
	vApex.SetVertex(apex);
	vBaseLeft.SetVertex(bLeft);
	vBaseRight.SetVertex(bRight);
	vBaseBack.SetVertex(bBack);
}// ////////////////////////////////////////////////
// ccenter.h
// 
// ////////////////////////////////////////////////
#ifndef CCENTER_H
#define CCENTER_H

void TetraCircumCenter(
double a[3], double b[3], double c[3], double d[3], 
double circumcenter[3], double *xi, double *eta, double *zeta);

#endif

/*****************************************************************************/
/*                                                                           */
/*  tetcircumcenter()   Find the circumcenter of a tetrahedron.              */
/*                                                                           */
/*  The result is returned both in terms of xyz coordinates and xi-eta-zeta  */
/*  coordinates, relative to the tetrahedron's point `a' (that is, `a' is    */
/*  the origin of both coordinate systems).  Hence, the xyz coordinates      */
/*  returned are NOT absolute; one must add the coordinates of `a' to        */
/*  find the absolute coordinates of the circumcircle.  However, this means  */
/*  that the result is frequently more accurate than would be possible if    */
/*  absolute coordinates were returned, due to limited floating-point        */
/*  precision.  In general, the circumradius can be computed much more       */
/*  accurately.                                                              */
/*                                                                           */
/*  The xi-eta-zeta coordinate system is defined in terms of the             */
/*  tetrahedron.  Point `a' is the origin of the coordinate system.          */
/*  The edge `ab' extends one unit along the xi axis.  The edge `ac'         */
/*  extends one unit along the eta axis.  The edge `ad' extends one unit     */
/*  along the zeta axis.  These coordinate values are useful for linear      */
/*  interpolation.                                                           */
/*                                                                           */
/*  If `xi' is NULL on input, the xi-eta-zeta coordinates will not be        */
/*  computed.                                                                */
/*                                                                           */
/*****************************************************************************/
#ifndef NULL
	#define NULL 0
#endif

void TetraCircumCenter(
double a[3], double b[3], double c[3], double d[3], 
double circumcenter[3], double *xi, double *eta, double *zeta)
{  
  double xba, yba, zba, xca, yca, zca, xda, yda, zda;
  double balength, calength, dalength;  double xcrosscd, ycrosscd, zcrosscd;
  double xcrossdb, ycrossdb, zcrossdb;  double xcrossbc, ycrossbc, zcrossbc;
  double denominator;  double xcirca, ycirca, zcirca;
  /* Use coordinates relative to point `a' of the tetrahedron. */
  xba = b[0] - a[0];  yba = b[1] - a[1];  zba = b[2] - a[2];  xca = c[0] - a[0];
  yca = c[1] - a[1];  zca = c[2] - a[2];  xda = d[0] - a[0];  yda = d[1] - a[1];
  zda = d[2] - a[2];  /* Squares of lengths of the edges incident to `a'. */
  balength = xba * xba + yba * yba + zba * zba;
  calength = xca * xca + yca * yca + zca * zca;
  dalength = xda * xda + yda * yda + zda * zda;
  /* Cross products of these edges. */  xcrosscd = yca * zda - yda * zca;
  ycrosscd = zca * xda - zda * xca;  zcrosscd = xca * yda - xda * yca;
  xcrossdb = yda * zba - yba * zda;  ycrossdb = zda * xba - zba * xda;
  zcrossdb = xda * yba - xba * yda;  xcrossbc = yba * zca - yca * zba;
  ycrossbc = zba * xca - zca * xba;  zcrossbc = xba * yca - xca * yba;
  /* Calculate the denominator of the formulae. */
#ifdef EXACT
  /* Use orient3d() from http://www.cs.cmu.edu/~quake/robust.html     */
  /*   to ensure a correctly signed (and reasonably accurate) result, */
  /*   avoiding any possibility of division by zero.                  */
  denominator = 0.5 / orient3d(b, c, d, a);
#else
  /* Take your chances with floating-point roundoff. */
  denominator = 0.5 / (xba * xcrosscd + yba * ycrosscd + zba * zcrosscd);
#endif
  /* Calculate offset (from `a') of circumcenter. */
  xcirca = (balength * xcrosscd + calength * xcrossdb + dalength * xcrossbc) *
           denominator;
  ycirca = (balength * ycrosscd + calength * ycrossdb + dalength * ycrossbc) *
           denominator;
  zcirca = (balength * zcrosscd + calength * zcrossdb + dalength * zcrossbc) *
           denominator;  circumcenter[0] = xcirca;  circumcenter[1] = ycirca;
  circumcenter[2] = zcirca;  
  if (xi != (double *) NULL) 
  {
    /* To interpolate a linear function at the circumcenter, define a    */
    /*   coordinate system with a xi-axis directed from `a' to `b',      */
    /*   an eta-axis directed from `a' to `c', and a zeta-axis directed  */
    /*   from `a' to `d'.  The values for xi, eta, and zeta are computed */
    /*   by Cramer's Rule for solving systems of linear equations.       */
    *xi = (xcirca * xcrosscd + ycirca * ycrosscd + zcirca * zcrosscd) *
          (2.0 * denominator);
    *eta = (xcirca * xcrossdb + ycirca * ycrossdb + zcirca * zcrossdb) *
           (2.0 * denominator);
    *zeta = (xcirca * xcrossbc + ycirca * ycrossbc + zcirca * zcrossbc) *
            (2.0 * denominator);  
  }
}


// /////////////////////////////////////////////////
// config.h
//
// author:		Aaron Licata
// creation date:	11/08/00
// last modified:	11/08/00
//
// purpose:
// system configuration and hardware dependecies

#ifndef CONFIG_H
#define CONFIG_H

#define PROJECT_PROGRAM_NAME		"Voronoi"
#define PROJECT_PROGRAM_NUMBER		"2"
#define APPLICATION_RELEASE			"2"
#define APPLICATION_VERSION 		"0"



#ifndef LINUX
#define LINUX
#endif

// Complilation settings
#define _DEBUG_STRICT	// assert
#define _DEBUG_APPOUT	// AppOut()

// System enabling options
#define ENABLE_OPTIMIZE_SPEED		0
#define ENABLE_OPTIMIZE_MEMORY		0
#define ENABLE_DEBUGGING			0
#define ENABLE_ERROR_CHECKING		0
#define ENABLE_ROBUST				0
#define ENABLE_EXACT_ARITHMETIC		0
#define ENABLE_NETWORKING           0

// General configuration settings
#define HALT_ON_ERROR				1	// exit application on error
#define ERROR_MODE_VERBOSE          0   // more detail in error messages


#endif
// /////////////////////////////////////////////////
// geomutil.h
//
// author:			Aaron Licata
// creation date:	02/09/00
// last modified:	02/09/00
//
// Header file for all general geometrical utilities
//

#ifndef GEOMUTIL_H
#define GEOMUTIL_H

#include "predicates.h"
#include "math.h"
#include "geom.h"

int const MINVERTEX = 4;
int const MAXVERTEX = 2;


// //////////////////////////////////////////////////////////
// file name:BoundBox3
//
// author:			Aaron Licata
// creation date:	14/02/01
// last modified:	21/04/01
// version number:	2
//
// description: class that implements the bounding box
//
// //////////////////////////////////////////////////////////

class BoundBox3
{
public:
   
    BoundBox3() ;                    //  default constructor
    BoundBox3(Vertex3& inMin, Vertex3& inMax); //  conversion constructor

    ~BoundBox3() ;                   //  destructor

	void SetBoundingBox(Vertex3& min, Vertex3& max);
	void CenterAtOrigin();
	void Center(Vertex3 &center);
	double MaxX() { return box[MAXVERTEX].x; }
	double MaxY() { return box[MAXVERTEX].y; }
	double MaxZ() { return box[MAXVERTEX].z; }
	double MinX() { return box[MINVERTEX].x; }
	double MinY() { return box[MINVERTEX].y; }
	double MinZ() { return box[MINVERTEX].z; }


private:
    Vertex3 box[8];
} ;


void MaxBox3(BoundBox3& bbox, Vertex3* v, int numVerts);
void TetrahedronCircumCenter(const Vertex3& v0, const Vertex3& v1, const Vertex3& v2, const Vertex3& v3, Vertex3& center);

bool IsFaceClockWise(Face3* face, Vector3* normal);
bool IsFaceOnConvexHull(Face3 *f);
bool IsVertexOnConvexHull(int sampleId);

void FlipVertexNormals(Vertex3* vertexArray, int vertexCount);
void FindAverageNormalFromAdjecentFaces(int sampleId, Vector3& normal);
void RetainSampleVertexSharedFaces(Vertex3* sampleVertex, list<Face3*>& temp);


void RandomizePointSet(Vertex3* vertexArray, int percentage, double max); 


// machine precision related functions 
double CalculateMachineTollerance();
double GetMachineTollerance();


// Shewchuck's incircle and orient3d routines
// this routines are from a C-API library
#ifdef __cplusplus
extern "C" {
#endif
	double orient3dfast(double *pa, double *pb, double *pc, double *pd);
#ifdef __cplusplus
}
#endif


#endif
// /////////////////////////////////////////////////
// geomutil.cpp
//
// author:			Aaron Licata
// creation date:	02/09/00
// last modified:	05/03/01
//
// Implementaion file for all general geometrical utilities
//
// /////////////////////////////////////////////////////////

#include "config.h"
#include "ccenter.h"
#include "geom.h"		// Vertex3
#include "geomutil.h"	


// tollerated thickness of the surface of a circusphere
double machineTollerance = 0.000001;



// ////////////////////////////////////////////////////////////
// function: BoundBox3()
//
// creation date:	17/10/00
// last modified:	17/10/00
// purpose: constructor
//
// arguments: none
//
// return value: none
// ////////////////////////////////////////////////////////////

BoundBox3::BoundBox3()
{
	box[0].x =  box[0].y = box[0].z = 0.0;
	box[1].x =  box[1].y = box[1].z = 0.0;
	box[2].x =  box[2].y = box[2].z = 0.0;
	box[3].x =  box[3].y = box[3].z = 0.0;
	box[4].x =  box[4].y = box[4].z = 0.0;
	box[5].x =  box[5].y = box[5].z = 0.0;
	box[6].x =  box[6].y = box[6].z = 0.0;
	box[7].x =  box[7].y = box[7].z = 0.0;

}   



// ////////////////////////////////////////////////////////////
// function: BoundBox3()
//
// creation date:	17/10/00
// last modified:	17/10/00
// purpose: constructor
//
// arguments: min, max vertices
//
// return value: none
// ////////////////////////////////////////////////////////////

BoundBox3::BoundBox3(Vertex3& min, Vertex3& max)
{
	box[0].x = min.x; box[0].y = min.y; box[0].z = max.z;
	box[1].x = max.x; box[1].y = min.y; box[1].z = max.z;
	box[2].x = max.x; box[2].y = max.y; box[2].z = max.z;
	box[3].x = min.x; box[3].y = max.y; box[3].z = max.z;
	box[4].x = min.x; box[4].y = min.y; box[4].z = min.z;
	box[5].x = max.x; box[5].y = min.y; box[5].z = min.z;
	box[6].x = max.x; box[6].y = max.y; box[6].z = min.z;
	box[7].x = min.x; box[7].y = max.y; box[7].z = min.z;
}



// ////////////////////////////////////////////////////////////
// function: ~BoundBox3()
//
// creation date:	17/10/00
// last modified:	17/10/00
// purpose: destructor
//
// arguments: none
//
// return value: none
// ////////////////////////////////////////////////////////////

BoundBox3::~BoundBox3()
{
	
}




// ////////////////////////////////////////////////////////////
// function: SetBoundingBox()
//
// creation date:	17/10/00
// last modified:	17/10/00
// purpose: destructor
//
// arguments: min and max vertices
//
// return value: none
// ////////////////////////////////////////////////////////////

void BoundBox3::SetBoundingBox(Vertex3& min, Vertex3& max)
{
	box[0].x = min.x; box[0].y = min.y; box[0].z = max.z;
	box[1].x = max.x; box[1].y = min.y; box[1].z = max.z;
	box[2].x = max.x; box[2].y = max.y; box[2].z = max.z;
	box[3].x = min.x; box[3].y = max.y; box[3].z = max.z;
	box[4].x = min.x; box[4].y = min.y; box[4].z = min.z;
	box[5].x = max.x; box[5].y = min.y; box[5].z = min.z;
	box[6].x = max.x; box[6].y = max.y; box[6].z = min.z;
	box[7].x = min.x; box[7].y = max.y; box[7].z = min.z;
}



// ////////////////////////////////////////////////////////////
// function: Center()
//
// creation date:	19/10/00
// last modified:	19/10/00
// purpose: destructor
//
// arguments: vertex 
//
// return value: none
// ////////////////////////////////////////////////////////////

void BoundBox3::Center(Vertex3 &center)
{
	center.x = MinX() + (MaxX() - MinX())/2;
	center.y = MinX() + (MaxY() - MinY())/2;
	center.z = MinX() + (MaxZ() - MinZ())/2;
}



// ////////////////////////////////////////////////////////////
// function: CenterAtOrigin()
//
// creation date:	19/10/00
// last modified:	19/10/00
// purpose: move center of box to the origin
//
// arguments: none
//
// return value: none
// ////////////////////////////////////////////////////////////

void BoundBox3::CenterAtOrigin()
{
	// TODO
	double xOffset = (MaxX() - MinX())/2;
	double yOffset = (MaxY() - MinY())/2;
	double zOffset = (MaxZ() - MinZ())/2;

	// first
	box[0].x = -xOffset;
	box[0].y = +yOffset;
	box[0].z = -zOffset;
	
	// second
	box[1].x = +xOffset;
	box[1].y = +yOffset;
	box[1].z = -zOffset;

	// MAX
	box[MAXVERTEX].x = +xOffset;
	box[MAXVERTEX].y = +yOffset;
	box[MAXVERTEX].z = +zOffset;

	// 3
	box[3].x = -xOffset;
	box[3].y = +yOffset;
	box[3].z = +zOffset;

	// MIN
	box[MINVERTEX].x = -xOffset;
	box[MINVERTEX].y = -yOffset;
	box[MINVERTEX].z = -zOffset;

	//
	box[5].x = -xOffset;
	box[5].y = -yOffset;
	box[5].z = +zOffset;

	//
	box[6].x = +xOffset;
	box[6].y = -yOffset;
	box[6].z = -zOffset;

	box[7].x = +xOffset;
	box[7].y = -yOffset;
	box[7].z = +zOffset;


}



// ////////////////////////////////////////////////////////////////////////
// general and global functions
//



// ////////////////////////////////////////////////////////////
// function: MaxBox3()
//
// creation date:	19/10/00
// last modified:	19/10/00
// purpose: set max bounding box of a point cloud
//
// arguments: vertex list and number of vertices
//
// return value: none
// ////////////////////////////////////////////////////////////

void MaxBox3(BoundBox3& box, Vertex3* v, int numVerts)
{
	int i;
	Vertex3 min, max;

	max.x = min.x = v[0].x;
	max.y = min.y = v[0].y;
	max.z = min.z = v[0].z;
	for (i = 0; i < numVerts; i++)
	{
		if (v[i].x > max.x) { max.x = v[i].x; }
		if (v[i].x < min.x) { min.x = v[i].x; }
		if (v[i].y > max.y) { max.y = v[i].y; }
		if (v[i].y < min.y) { min.y = v[i].y; }
		if (v[i].z > max.z) { max.z = v[i].z; }
		if (v[i].z < min.z) { min.z = v[i].z; }
	}
	box.SetBoundingBox(min, max);
}


// ///////////////////////////////////////////////////////////
// function: TetrahedronCircumCenter()
//
// creation date:	05/11/00
// last modified:	05/11/00
// purpose: find circumcenter of a tetrahedron
//
// arguments: vertices
//
// return value: none
// ///////////////////////////////////////////////////////////

void TetrahedronCircumCenter(const Vertex3& p0, const Vertex3& p1, const Vertex3& p2, const Vertex3& p3, Vertex3& center)
{
	double a[3];
	double b[3];
	double c[3];
	double d[3];

	a[0] = p0.x; a[1] = p0.y; a[2] = p0.z;
	b[0] = p1.x; b[1] = p1.y; b[2] = p1.z;
	c[0] = p2.x; c[1] = p2.y; c[2] = p2.z;
	d[0] = p3.x; d[1] = p3.y; d[2] = p3.z;

	double* xi = NULL;
	double cc[3];

	TetraCircumCenter(a, b, c, d, cc, xi, xi, xi);

	center.x = cc[0] + a[0];
	center.y = cc[1] + a[1];
	center.z = cc[2] + a[2];
}

// ///////////////////////////////////////////////////////////
// function: IsFaceClockWise()
//
// creation date:	05/03/01
// last modified:	05/03/01
// purpose: establish whether a face in 3-d is clockwise or 
//          counterclockwise (see predicates.c for details)
//
// arguments: face is a pointer to a known face (triangle)
//            normal is a normal to the face 
//
// return value: boolean true if cw, false if ccw
// ///////////////////////////////////////////////////////////

bool IsFaceClockWise(Face3 *face, Vector3 *normal)
{
	double pa[3]; // face vertex a (1) 
	double pb[3]; // face vertex b (2)
	double pc[3]; // face vertex c (3)
	double pd[3]; // point d is either above or below face

	  assert(normal);

      // convert application native vertex and vector format
	  // into format used by Shewchuck's routines in predicates.c

	  // vertex 0
	  pa[0] = face->V(0)->x;
	  pa[1] = face->V(0)->y;
	  pa[2] = face->V(0)->z;

	  // vertex 1
	  pb[0] = face->V(1)->x;
	  pb[1] = face->V(1)->y;
	  pb[2] = face->V(1)->z;
 
	  // vertex 2
	  pc[0] = face->V(2)->x;
	  pc[1] = face->V(2)->y;
	  pc[2] = face->V(2)->z;

	  // point d 
	  pd[0] = pa[0] + normal->x;
	  pd[0] = pa[1] + normal->y;
	  pd[0] = pa[2] + normal->z;

   
    // check if point d lies below or above the face
    if (orient3dfast(pa, pb, pc, pd) < 0)
        return true; // d lies below, clockwise 
     else
        return false; // d lies above, counterclockwise

  return false;
}


// ///////////////////////////////////////////////////////////
// function: RandomizePointSet()
//
// creation date:	27/03/01
// last modified:	27/03/01
// purpose: add random displacement to each vertex 
//          of the vertex array
//
// arguments: the vertex array to randomize
//           
// return value: none 
// ///////////////////////////////////////////////////////////

void RandomizePointSet(Vertex3* vertexArray, int percentage, double max)
{

	max = max / 10.0;
	for (int vertexId = 0; vertexId < Vertex3::GetGlobalVertexCount(); vertexId++)
	{
		Vertex3* v = Vertex3::GetVertex(vertexId);
		v->x += ((double)(rand()%percentage)/2000.0)*v->x;
		v->y += ((double)(rand()%percentage)/2000.0)*v->y;
		v->z += ((double)(rand()%percentage)/2000.0)*v->z;
	}
}



// ///////////////////////////////////////////////////////////
// function: IsFaceOnConvexHull()
//
// creation date:	13/02/01
// last modified:	13/02/01
// purpose: tell if a face belongs to the 3-d convex-hull
// of the Delaunay tetrahedralization
//
// arguments: face that might belong to the convex-hull
// ///////////////////////////////////////////////////////////
bool IsFaceOnConvexHull(Face3 *f)
{
	return (f->neigh == NO_LINK);
}



// ///////////////////////////////////////////////////////////
// function: IsVertexOnConvexHull()
//
// creation date:	18/02/01
// last modified:	18/02/01
// purpose: tell if a vertex belongs to the 3-d convex-hull
// of the Delaunay tetrahedralization
//
// arguments: vertex id that might belong to the convex-hull
// ///////////////////////////////////////////////////////////
bool IsVertexOnConvexHull(int vertexId)
{
	Vertex3 *v = Vertex3::GetVertex(vertexId);
	return (v->flag == GEOM_ON_CONVEX_HULL);
}



// ///////////////////////////////////////////////////////////
// function: CalculateMachineTollerance()
//
// creation date:	10/12/00
// last modified:	18/02/01
//
// purpose: find the smallest positive real number representable 
// by the machine running this code
//
// arguments: none
// ///////////////////////////////////////////////////////////

double CalculateMachineTollerance()
{
	double num1 = 0.0;
	double num2 = 0.1;
	double tollerance;

	while (fabs(num1 - num2) > 0)
	{
		tollerance = num2;
		num2 /= 2;
	}
	return machineTollerance = tollerance;
}




// ///////////////////////////////////////////////////////////
// function:GetMachineTollerance()
//
// creation date:	10/12/00
// last modified:	18/02/01
//
// purpose: return  smallest positive real number representable 
// by the machine running this code
//
// arguments: none
// ///////////////////////////////////////////////////////////

double GetMachineTollerance()
{
	return machineTollerance;
}



// ///////////////////////////////////////////////////////////
// function:FlipVertexNormals()
//
// creation date:	26/12/00
// last modified:	26/02/01
//
// purpose: flip the direction of the vertex normals of vertex array   
//
// arguments: vertex array and its size
// ///////////////////////////////////////////////////////////

void FlipVertexNormals(Vertex3* vertexArray, int vertexCount)
{
	for (int i = 0 ; i < vertexCount ; i++)
	{
		Vertex3* vertex = Vertex3::GetVertex(i);

		vertex->normal.x = -vertex->normal.x;
		vertex->normal.y = -vertex->normal.y;
		vertex->normal.z = -vertex->normal.z;

	}
}



// ///////////////////////////////////////////////////////////
// function: FindAverageNormalFromAdjecentFaces()
//
// creation date:	14/02/01
// last modified:	17/02/01
// purpose: calculate the average normal vector to the surface 
// around the neighbouring faces (triangles) 
//
// arguments: sampleId is an index to the vertex list
//            normal is a reference to the normal to be computed 
//
// return value: none
// ///////////////////////////////////////////////////////////
void FindAverageNormalFromAdjecentFaces(int sampleId, Vector3& averageFaceNormal)
{
 	// grab a pointer to the Delaunay vertex
	Vertex3 *sampleVertex = Vertex3::GetVertex(sampleId);

	// iterators to neighbouring tetrahedra
	TetraList::Itr startItr = sampleVertex->neigh->Begin();
	TetraList::Itr endItr = sampleVertex->neigh->End();

	if (startItr == endItr)
	{
     // this Delaunay vertex has not neighbouring Voronoi vertices
		return;
	}

	// loop through neighbouring Tetrahedra
	// and isolate the surface faces
	list<Face3*> temp;
	for (; startItr != endItr; startItr++)
	{
		Tetrahedron *tetra = *startItr;
		temp.push_back(tetra->F(0));
		temp.push_back(tetra->F(1));
		temp.push_back(tetra->F(2));
		temp.push_back(tetra->F(3));
	}
	// find faces contributing to the average normal to the sample vertex
	RetainSampleVertexSharedFaces(sampleVertex, temp);
	
	// calculate avarage out of each face's normal vector
	int numTotalVectors = (int)temp.size();
	averageFaceNormal.Set(0.0, 0.0, 0.0);
	for (int i = 0; i < numTotalVectors; i++)
	{
		// make a normal vector out of each face
		Face3 *face = temp.back();
		temp.pop_back();

		// note: face normal are calculated during face creation
		// also, faces are assumed to be already clockwise (see LinkVerticesToNeighTetrahedra())
		Vector3 tempNormal = face->Normal(); 

		// add this normal vector to the total average
		averageFaceNormal.x += tempNormal.x;
		averageFaceNormal.y += tempNormal.y;
		averageFaceNormal.z += tempNormal.z;
	}
	averageFaceNormal.x /= -numTotalVectors;
	averageFaceNormal.y /= -numTotalVectors;
	averageFaceNormal.z /= -numTotalVectors;
}

// ////////////////////////////////////////////////////////////
// function: RetainSampleVertexSharedFaces()
//
// creation date:	17/02/01
// last modified:	17/02/01
// purpose: filter out from teporary list those external faces 
// that do not share the sample vertex 
//
// arguments: sampleVertex is the Delaunay vertex
//            temp is a list of Face3 pointers
//
// return value: none
// ////////////////////////////////////////////////////////////
void RetainSampleVertexSharedFaces(Vertex3* sampleVertex, list<Face3*>& temp)
{
	list<Face3*>::iterator startItr = temp.begin();
	list<Face3*>::iterator endItr   = temp.end();
	list<Face3*>::iterator disposibleItr;

	while ( startItr != endItr)
	{
		Face3 *face = *startItr;
		assert(face != NO_LINK);
		if (!IsFaceOnConvexHull(face))
		{
			disposibleItr = startItr++;
			temp.erase(disposibleItr);
		}
		else
		{
			startItr++;
		}
	}
}
// //////////////////////////////////////////////////////////
// file name: filept2.h
//
// author:		Aaron Licata
// creation date:	28/02/01
// last modified:	28/02/01
// version number	1
//
// description: file i/o interface for pt2 format
//
// //////////////////////////////////////////////////////////


#ifndef FILE_PT2_H
#define FILE_PT2_H

#include "geom.h"

int PT2ReadFile(const char *filename, Skeleton *o);

#endif
// //////////////////////////////////////////////////////////
// file name: filept2.cpp
// author:		Aaron Licata
// creation date:	28/02/01
// last modified:	28/02/01
// version number	1
//
// description: file i/o module implementation for pt2 format
//
// //////////////////////////////////////////////////////////

#include "config.h"
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>
#include "geom.h"
#include "rabdata.h"
#include "filept2.h"



// ///////////////////////////////////////////////////////////
// function: PT2ReadFirstToken()
//
// creation date:	27/02/01
// last modified:	27/02/01
// purpose: read the first token from a file pointer. It is 
// assumed to be an integer
//
// arguments: fp file pointer
//            destination buffer for token 
//
// return value: none
// ///////////////////////////////////////////////////////////

void PT2ReadFirstToken(FILE *fp, char *token)
{
	int i = 0;

	while ((token[i] = fgetc(fp)) != '\n')
	{
		i++;
	}
	token[i] = '\0';
}



// ///////////////////////////////////////////////////////////
// function: PT2ReadNextLine()
//
// creation date:	27/02/01
// last modified:	27/02/01
// purpose: read in a line from a file pointer an save result 
// in three token buffers. It is assumed that a line is made 
// of three tokens for x,y,z coordinates. 
//
// arguments: file pointer 
//            three destination token buffers 
//
// return value: none
// ///////////////////////////////////////////////////////////

void PT2ReadNextLine(FILE *fp, char *token1, char *token2, char *token3)
{

	int i = 0;
  
	while ((token1[0] = fgetc(fp)) == ' ' || token1[0] == '\t');
	i = 1;
	while ((token1[i] = fgetc(fp)) != ' ')
	{
		i++;
	}
	token1[i] = '\0';

	while ((token2[0] = fgetc(fp)) == ' ' || token2[0] == '\t');
	i = 1;
	while ((token2[i] = fgetc(fp)) != ' ')
	{
		i++;
	}
	token2[i] = '\0';

	while ((token3[0] = fgetc(fp)) == ' ' || token3[0] == '\t');
	i = 1;
	while ((token3[i] = fgetc(fp)) != '\n')
	{
		i++;
	}
	token3[i] = '\0';

}



// ///////////////////////////////////////////////////////////
// function: PT2ReadFile()
//
// creation date:	27/02/01
// last modified:	27/02/01
// purpose: open and read a file of format pt2. Stores result in
// a vertex array
//
// arguments: filename to open and read in
//            object holding the vertex array 
//
// return value: 1 success, 0 failure
// ///////////////////////////////////////////////////////////

int PT2ReadFile(const char *filename, Skeleton *o)
{

	char token[20];
	
	memset(&token[0], 20, sizeof(char));

	if (!o) return 0;
	
	AppOutN("reading file ");

        FILE *fp = fopen(filename, "r");
	if (!fp) return 0;

	PT2ReadFirstToken(fp, token);
	o->vertCount = atoi(token);
	AppOut("number of points : ");
	AppOutN(o->vertCount);

	o->vert = new Vertex3 [o->vertCount+4];

	AppOutN("reading point coordinates");
	char token1[220];
	char token2[220];
	char token3[220];
	double mx = 0;
	double my = 0;
	double mz = 0;

	int count = 0;
	while (count < o->vertCount)
	{
		PT2ReadNextLine(fp, token1, token2, token3);
		o->vert[count].x = atof(token1);
		o->vert[count].y = atof(token2);
		o->vert[count].z = atof(token3);
		if (o->vert[count].x > mx) mx = o->vert[count].x;
		if (o->vert[count].y > my) my = o->vert[count].y;
		if (o->vert[count].z > mz) mz = o->vert[count].z;

		AppOut(count); AppOut(" ");
		AppOut(o->vert[count].x); AppOut(" "); 
		AppOut(o->vert[count].y); AppOut(" "); 
		AppOut(o->vert[count].z); AppOut(" "); 
		AppEndl();

		count++;	
	}
	AppOutN("finished reading file");
	
	AppOutN("normalizing coordinates");
	double max;
	if (mx > my)
		max = mx;
	else
		max = my;

	if (max < mz) max = mz;
	
	for (int j=0; j < o->vertCount; j++)
	{
		o->vert[j].x /= max;
		o->vert[j].y /= max;
		o->vert[j].z /= max;

	}

	return 1;
}


// /////////////////////////////////////////////////
// apperr.h
//
// author:			Aaron Licata
// creation date:	01/09/00
// last modified:	01/09/00
//
// Header file for application error handling

#ifndef APPERROR_H
#define APPERROR_H

// Application errors
#define APPERR_TETRA_ALLOC				"error #1000: application cannot allocatate memory for a new tetrahedron"
#define APPERR_FACE_ALLOC				"error #1010: application cannot allocatate memory for a new face"
#define APPERR_EDGE_ALLOC				"error #1020: application cannot allocatate memory for a new edge"

#define APPERR_INSUFFICIENT_SAMPLE_DENSITY	"error #1100: data cannot be processed because its sample density is insufficient"
#define APPERR_2D_OR_1D_SAMPLES				"error #1110: data cannot be processed because is 2-dimensional or 1-dimensional"



// System Errors
#define SYSERR_NO_ALLOC  "error #2000: system has exhuasted memory resources"

// Application Exit Number
#define APPERR_EXIT_ERROR_NO	1


void AppError(char *);

#endif


// /////////////////////////////////////////////////
// apperr.cpp
//
// author:			Aaron Licata
// creation date:	01/09/00
// last modified:	01/09/00
//
// Implementation file for application error handling

#include "config.h"		// HALT_ON_ERROR
#include "clock.h"		// GetTimeStamp
#include "appio.h"		// AppOut
#include "apperr.h"		// AppError, APPERR_EXIT_NO
#include <stdlib.h>		// exit

// ///////////////////////////////////////////////////////////
// function: AppError()
//
// creation date:	01/09/00
// last modified:	01/09/00
// purpose: OS independent error message 
//
// arguments: error message to print

// return value: none
// ///////////////////////////////////////////////////////////
void AppError(char *msg)
{
	AppOut(msg);

	if (ERROR_MODE_VERBOSE)
	{
		char timeStamp[80];
		GetTimeStamp(timeStamp);
		AppOut(timeStamp);
	}

	AppEndl();
	

	if (HALT_ON_ERROR)
	{
		exit(APPERR_EXIT_ERROR_NO);
	}
}
// /////////////////////////////////////////////////
// appio.h
//
// author:			Aaron Licata
// creation date:	01/09/00
// last modified:	01/09/00
//
// Header file for application i/o handling

#ifndef APPIO_H
#define APPIO_H

// Output Modes
#define APPOUT_STDOUT     1
#define APPOUT_STDERR     2
#define APPOUT_LOGFILE    4
#define APPOUT_MAINWINDOW 8
#define APPOUT_AUXSCREEN  16

#define APPOUT_LOGFILE_NAME "logfile.txt"

// Macros
#define AppOutN(msg) AppOut(msg);AppEndl()

// Application and environment dependent I/O functions
void AppOut(char *message);
void AppOut(double value);
void AppOut(int value);
void AppEndl();
void AppOutLn(int length);
void AppOutMode(int mode);
void AppOutEnableCounter(bool enabled);
void AppGetKey();

#endif
// ////////////////////////////////////////////////////////
// appio.cpp
//
// author:		Aaron Licata
//
// creation date:	01/09/00
// last modified:	01/09/00
//
// purpose: implementaion file for application i/o handling
//
// /////////////////////////////////////////////////////////

#include <iostream.h>
#include <fstream.h>

// OS dependent includes
#ifdef WIN32
	#include <conio.h>
#elif WIN32

#elif LINUX

#elif MSDOS

#endif

#include "clock.h"
#include "appio.h"



// ////////// global variables //////////////////
bool fileLogIsEnabled = false;
bool globalCounterIsEnabled = false;
bool timeStampIsEnabled = true;
long globalCounter = 0;				// unique ouput line id
int appOutMode = APPOUT_STDOUT;			// mode of operation
ofstream appLogFile;				// output log file 



// ///////////////////////////////////////////////////////////
// function: AppOutEnableFileLog()
//
// creation date:	01/09/00
// last modified:	03/10/00
// purpose: start logging activity
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void AppOutEnableFileLog()
{
	appLogFile.open(APPOUT_LOGFILE_NAME);
	fileLogIsEnabled = true;
}



// ///////////////////////////////////////////////////////////
// function: AppOutDisableFileLog()
//
// creation date:	01/09/00
// last modified:	01/10/00
// purpose: stop logging activity
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void AppOutDisableFileLog()
{
	appLogFile.close();
	fileLogIsEnabled = false;
}



// ///////////////////////////////////////////////////////////
// function: AppOutMode()
//
// creation date:	03/09/00
// last modified:	09/10/00
// purpose: change mode of outputting information
//
// arguments: chosen mode 
//
// return value: none
// ///////////////////////////////////////////////////////////

void AppOutMode(int mode) 
{

	if (mode == APPOUT_LOGFILE)
	{
		AppOutEnableFileLog();
	}
	else if (appOutMode == APPOUT_LOGFILE)
	{
		AppOutDisableFileLog();
	}
	appOutMode = mode;
}



// ///////////////////////////////////////////////////////////
// function: AppOut()
//
// creation date:	01/09/00
// last modified:	11/10/00
// purpose: ouput a string message 
//
// arguments: message to ouput 
//
// return value: none
// ///////////////////////////////////////////////////////////
void AppOut(char *message)
{
	if (globalCounterIsEnabled)
	{
		globalCounter++;
	}

	switch (appOutMode)
	{
	case APPOUT_STDOUT:
			if (globalCounterIsEnabled) cout << globalCounter << ":";
			cout << message;
			break;
	case APPOUT_STDERR:
			if (globalCounterIsEnabled) cerr << globalCounter << ":";
			cerr << message;
			break;
	case APPOUT_LOGFILE:
			if (globalCounterIsEnabled) appLogFile << globalCounter << ":";
			if (fileLogIsEnabled)
			{	
				appLogFile << message;
			}
			break;
	}
}



// ///////////////////////////////////////////////////////////
// function: AppOut()
//
// creation date:	01/09/00
// last modified:	11/10/00
// purpose: ouput a double value
//
// arguments: value to ouput 
//
// return value: none
// ///////////////////////////////////////////////////////////

void AppOut(double value)
{
	if (globalCounterIsEnabled)
	{
		globalCounter++;
	}

	switch (appOutMode)
	{
	case APPOUT_STDOUT:
			cout << value;
			break;
	case APPOUT_STDERR:
			cerr << value;
			break;
	case APPOUT_LOGFILE:
			if (fileLogIsEnabled)
			{	
				appLogFile << value;
			}
			break;
	}
}




// ///////////////////////////////////////////////////////////
// function: AppOut()
//
// creation date:	01/09/00
// last modified:	11/10/00
// purpose: ouput a integer value
//
// arguments: value to ouput 
//
// return value: none
// ///////////////////////////////////////////////////////////

void AppOut(int value)
{
	if (globalCounterIsEnabled)
	{
		globalCounter++;
	}

	switch (appOutMode)
	{
	case APPOUT_STDOUT:
			cout << value;
			break;
	case APPOUT_STDERR:
			cerr << value;
			break;
	case APPOUT_LOGFILE:
			if (fileLogIsEnabled)
			{	
				appLogFile << value;
			}
			break;
	}
}




// ///////////////////////////////////////////////////////////
// function: AppEndl()
//
// creation date:	01/09/00
// last modified:	11/10/00
// purpose: ouput a new line
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void AppEndl() 
{
	switch (appOutMode)
	{
	case APPOUT_STDOUT:
			cout << endl;
			break;
	case APPOUT_STDERR:
			cerr << endl;
			break;
	case APPOUT_LOGFILE:
			if (fileLogIsEnabled)
			{	
				appLogFile << endl;
			}
			break;
	}
}


// ///////////////////////////////////////////////////////////
// function: AppOutLn()
//
// creation date:	01/09/00
// last modified:	11/10/00
// purpose: ouput a line of '-' characters
//
// arguments: length of line
//
// return value: none
// ///////////////////////////////////////////////////////////

void AppOutLn(int length)
{
	int i;
	char timeStamp[80];

	GetTimeStamp(timeStamp);
	switch (appOutMode)
	{
	case APPOUT_STDOUT:
			for (i=0; i<length/2;i++)
			{
				cout << "-";
			}
			if (timeStampIsEnabled) cout << timeStamp;
			for (i=0; i<length/2;i++)
			{
				cout << "-";
			}
			cout << endl;
			break;
	case APPOUT_STDERR:
			for (i=0; i<length/2;i++)
			{
				cerr << "-";
			}
			if (timeStampIsEnabled) cerr << timeStamp;
			for (i=0; i<length/2;i++)
			{
				cerr << "-";
			}
			cerr << endl;
			break;
	case APPOUT_LOGFILE:
			if (fileLogIsEnabled)
			{	
				for (i=0; i<length/2;i++)
				{
					appLogFile << "-";
				}
				if (timeStampIsEnabled) appLogFile << timeStamp;
				for (i=0; i<length/2;i++)
				{
					appLogFile << "-";
				}
				appLogFile << endl;
			}
			break;
	}

}



// ///////////////////////////////////////////////////////////
// function: AppOutEnableCounter()
//
// creation date:	01/09/00
// last modified:	05/09/00
// purpose: enable the ouput line counter
//
// arguments: state of the counter
//
// return value: none
// ///////////////////////////////////////////////////////////

void AppOutEnableCounter(bool enabled) 
{ 
	globalCounter = 0;
	globalCounterIsEnabled = enabled; 
}



// ///////////////////////////////////////////////////////////
// function: AppGetKey()
//
// creation date:	11/10/00
// last modified:	12/10/00
// purpose: pause until user presses a key
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void AppGetKey()
{
#ifdef WIN32
	_getch();
#endif
}


#ifndef GEOSTAT_H
#define GEOSTAT_H

#include "geom.h"

#define TETRALIST_STATS		1
#define TETRA_STATS			2

void ShowTetraListStatistics(TetraList& tetraList, int mode);
void ShowTetraStatistics(Tetrahedron* tetra);

#endif

#include "geom.h"
#include "appio.h"
#include "geostat.h"



// ////////////////////////////////////////////////////////////
// function: ShowTetraListStatistics(()
//
// creation date:	19/10/00
// last modified:	19/10/00
// purpose: show statistics
//
// arguments: tetralist to inspect and stat mode
//
// return value: none
// ////////////////////////////////////////////////////////////

void ShowTetraListStatistics(TetraList& tetraList, int mode)
{
	if (mode & TETRALIST_STATS)
	{
		AppOutN("=====TETRAHEDRA STATISTICS=====");
		AppOut("number of tetrahedra      : ");
		AppOutN((int)tetraList.Size());
		AppOut("number of faces           : ");
		AppOutN(4*(int)tetraList.Size());
		AppOut("size of tetrahedron       : ");
		AppOutN((int)sizeof(Tetrahedron));
		AppOut("memory used for tetrahedra: ");
		AppOut((((int)tetraList.Size())*(int)sizeof(Tetrahedron))/1024);
		AppOut(" Kb");
		AppEndl();
        AppOutN("...............................................");

		AppOut("number of total points  : ");
		AppOutN((int)Vertex3::GetGlobalVertexCount());
		AppOut("size of a vertex        : ");
		AppOutN((int)(sizeof(Vertex3)));
        AppOut("memory used for vertices: ");
		AppOut(((int)Vertex3::GetGlobalVertexCount()*(int)sizeof(Vertex3))/1024);
		AppOut(" Kb ");
		AppEndl();

	}

	if (mode & mode)
	{
		
	}

	if (mode & TETRA_STATS)
	{
		TetraList::Itr startIter;
		TetraList::Itr endIter;
		
		startIter = tetraList.Begin();
		endIter = tetraList.End();
		int size = tetraList.Size();

		for (; startIter != endIter; startIter++)
		{
			Tetrahedron *tetra = *startIter;
			ShowTetraStatistics(tetra);
		}
	}
}



// ////////////////////////////////////////////////////////////
// function: ShowTetraStatistics()
//
// creation date:	19/10/00
// last modified:	19/10/00
// purpose: show statistics
//
// arguments: tetrahedron to inspect
//
// return value: none
// ////////////////////////////////////////////////////////////

void ShowTetraStatistics(Tetrahedron* tetra)
{
	AppOutN("=====TETRA STATS=====");
	AppOutN("N0 N1 N2 N3 : ");
	AppOut((int)tetra->F(0)); 
	AppOut(" ");
	AppOut((int)tetra->F(1)); 
	AppOut(" ");
	AppOut((int)tetra->F(2)); 
	AppOut(" ");
	AppOut((int)tetra->F(0)); 
	AppEndl();
}
// //////////////////////////////////////////////////////////
// file name: interface.h
//
// author:			Aaron Licata
// creation date:	21/04/01
// last modified:	21/04/01
// version number:	1
//
// description: file for abstract interfaces
//
// //////////////////////////////////////////////////////////


#ifndef GEOMETRY_BUILDER_INTERFACE_H
#define GEOMETRY_BUILDER_INTERFACE_H

#include "geom.h"
// //////////////////////////////////////////////////////////
// class name: GeometryBuilderInterfac
//
// author:			Aaron Licata
// creation date:	21/04/01
// last modified:	21/04/01
// version number:	1
//
// description: abstract interface for a geometry builder
//
// //////////////////////////////////////////////////////////

class GeometryBuilderInterface 
{

public:
	GeometryBuilderInterface() {}

	virtual void Build (TetraList&) = 0;

};


#endif

// /////////////////////////////////////////////////
// math.h
//
// author:			Aaron Licata
// creation date:	20/08/00
// last modified:	17/09/00
//
// Header file for all general math data structures
// and procedures

#ifndef MATH_MODULE_H
#define MATH_MODULE_H

#include <math.h>

// constants
#define MACHINE_TOLLERANCE 0.0
#define INFINITY 999999.0

// macros

// find the square distance of two points
#define SQUARE_DISTANCE3(point, centre) (point.x-centre.x)*(point.x-centre.x)+(point.y-centre.y)*(point.y-centre.y)+(point.z-centre.z)*(point.z-centre.z)
// find the square distance of two pointers to point objects
#define SQUARE_DISTANCE3P(point, centre) (point->x-centre->x)*(point->x-centre->x)+(point->y-centre->y)*(point->y-centre->y)+(point->z-centre->z)*(point->z-centre->z)

// ///////////////////////////////////////////////////////////
// class Vector3
//
// creation date:	20/08/00
// last modified:	17/02/01
//
// purpose: class reprensenting a vector in 3-d space
// ///////////////////////////////////////////////////////////
class Vector3
{
public:
	Vector3() { x=y=z=0.0;}
	Vector3(double vx, double vy, double vz) { x=vx; y=vy; z=vz; }
	void Set(double vx, double vy, double vz) { x=vx; y=vy; z=vz; }
	void Set(Vector3& v) { x=v.x; y=v.y; z=v.z; }
	double Magnitude() { return sqrt(x*x + y*y + z*z); }
	void Normalize() { double m = Magnitude(); x /= m; y /= m; z /= m; }
public:
	double x, y, z;
};

// scalar product between two vectors in 3-d space
double DotProduct3(Vector3 *v1, Vector3 *v2);

// cross product between two vectors in 3-d space
void CrossProduct3(Vector3& v1, Vector3& v2, Vector3& result);

#endif
// file name: math.cpp
//
// author:			Aaron Licata
// creation date:	14/02/01
// last modified:	17/02/01
// version number:	2
//
// description: math function module
//
// //////////////////////////////////////////////////////////

#include "config.h"
#include "math.h"		// DotProduct3
#include <stdlib.h>		// assert


// ////////////////////////////////////////////////////////////
// function: DotProduct() and CrossProduct()
//
// creation date:	29/12/00
// last modified:	29/12/00
// purpose: dot and cross products
//
// arguments: vectors
//
// return value: none
// ////////////////////////////////////////////////////////////

#if (ENABLE_EXACT_ARITHMETIC == 1)
	// use J.Shewchuck exact arithmetics rountine 
	double DotProduct3(Vector3 *v1, Vector3 *v2)
	{
		// TODO
		assert(0);
	}

    void CrossProduct3(Vector3& v1, Vector3& v2, Vector3& result)
	{
		assert(0);
	}

#else
// ///////////////////////////////////////////////////////////
// function: DotProduct3()
//
// creation date:	12/02/01
// last modified:	17/02/01
// purpose: scalar product between two vectors in 3-d space
//
// arguments: first and second vectors 
// ///////////////////////////////////////////////////////////

double DotProduct3(Vector3 *v1, Vector3 *v2) 
{
	return v1->x*v2->x + v1->y*v2->y + v1->z*v2->z; 
}



// ///////////////////////////////////////////////////////////
// function: CrossProduct3()
//
// creation date:	17/02/01
// last modified:	17/02/01
// purpose: vector product between two vectors in 3-d space
//
// arguments: first, second vectors and uknown normal vector 
// ///////////////////////////////////////////////////////////

void CrossProduct3(Vector3& v1, Vector3& v2, Vector3& result)
{
	result.x = (v1.y * v2.z) - (v1.z * v2.y);
	result.y = (v1.z * v2.x) - (v1.x * v2.z);
	result.z = (v1.x * v2.y) - (v1.y * v2.x);
}

#endif // end of non-exact version


// ///////////////////////////////////////////////////////////
// file name: rendergl.h//
// author:			Aaron Licata
// creation date:	28/02/01
// last modified:	28/02/01
// version number:	1
//
// description: opengl redering interface
//
// ///////////////////////////////////////////////////////////

#ifndef OPENGL_RENDERER_H
#define OPENGL_RENDERER_H

#include <GL/gl.h>

#include "geom.h"
#include "visualize.h"
#include "visdebug.h"



// ////////////////////////////////////////////////////////////////
// class Viewport
//
// author:		Aaron Licata
// creation date:	30/10/00
// last modified:	22/04/01
//
// purpose: class representing the viewport
//
// /////////////////////////////////////////////////////////////////
struct Viewport
{
	GLfloat width;
	GLfloat height;
};

// ////////////////////////////////////////////////////////////////
// class Viewvolume
//
// author:		Aaron Licata
// creation date:	30/10/00
// last modified:	22/04/01
//
// purpose: class representing the viewport
//
// /////////////////////////////////////////////////////////////////class ViewingVolume
class ViewingVolume
{
public:
	ViewingVolume() { zNear = zFar = fov = aspect = left = right = bottom = top = 0.0; }

public:
	GLdouble zNear;
	GLdouble zFar;
	
	// mothod1
	GLdouble fov;
	GLdouble aspect;

	// method2
	GLdouble left;		
	GLdouble right;	
	GLdouble bottom;
	GLdouble top;	

};



// ////////////////////////////////////////////////////////////////
// class Camera
//
// author:		Aaron Licata
// creation date:	30/10/00
// last modified:	22/04/01
//
// purpose: class representing the OpenGL camera
//
// /////////////////////////////////////////////////////////////////

struct Camera
{
	Vector3 pos;	// eye position
	Vector3 at;		// reference point (target)
	Vector3 up;		// up vector
	Vector3 rot;	// added rotation angle

};



// ////////////////////////////////////////////////////////////////
// class VisualContext 
//
// author:		Aaron Licata
// creation date:	30/10/00
// last modified:	22/04/01
//
// purpose: class representing the OpenGL VisualContext 
//
// /////////////////////////////////////////////////////////////////

class VisualContext 
{
public:
	VisualContext() { sampleId = 0; obj = NULL; }
	~VisualContext() {  tetraList.DeleteAll(); }
	void Clear() { tetraList.DeleteAll(); }
public:
	Camera camera;
	ViewingVolume viewVolume;
	Viewport viewport;

	BoundBox3 box;
	SuperTetra superTetra;
	VisualDebug visualDebugger;

	GeometryVisualizer visualizer;
	int sampleId;
	TetraList tetraList;
	Skeleton *obj;
};


void GLInitialize(VisualContext& vc);
void GLRender(VisualContext& vc);
void GLIdle(VisualContext& vc);
void GLResize(VisualContext& vc, int width, int height);
void ToggleGLIdlePause();

#endif

// ///////////////////////////////////////////////////////////
// file name: rendergl.cpp
//
// author:			Aaron Licata
// creation date:	28/02/01
// last modified:	28/02/01
// version number:	1
//
// description: opengl redering implementation module
//
// ///////////////////////////////////////////////////////////

#include "config.h"
#ifdef WIN32
	#include <windows.h>
#endif

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>

#include <stdio.h>
#include <stdlib.h>
#include "math.h"
#include "geom.h"
#include "geomutil.h"
#include "delaunay.h"
#include "visualize.h"
#include "visdebug.h"
#include "STL.h"

#include "rendergl.h"


int pause;

// ///////////////////////////////////////////////////////////
// function: GLInitialize()
//
// creation date:	11/01/01
// last modified:	11/01/01
// purpose: initialize openGL state machine using a visual context
// arguments: visual context object
//
// return value: none
// ///////////////////////////////////////////////////////////

void GLInitialize(VisualContext& vc)
{

	GLfloat ambient[] = { 0.4f, 0.4f, 0.3f, 1.0f };
	GLfloat diffuse[] = { 0.7, 0.7, 0.5, 1.0 };
	GLfloat specular[] = { 0.3, 0.4, 0.4, 1.0 };
	GLfloat lightpos[] = { 0.5, 0.4, 1.0, 0.0 };
///////////////////////////////////////////////////////////////////////////////



    glClearDepth(1.0);
    glDepthFunc(GL_LESS);
    glShadeModel(GL_SMOOTH);

    glEnable(GL_DEPTH_TEST);

    
	//////////////Establish viewing volume: method1 ///////////
	/*
	assert(vc.viewport.width != 0 && vc.viewport.height != 0);

	vc.viewVolume.fov = 60.0;
	vc.viewVolume.aspect = vc.viewport.width / vc.viewport.height;
	vc.viewVolume.zNear = 1;
	vc.viewVolume.zFar = 2000;

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(
		vc.viewport.fov, 
		vc.viewport.aspect,
		vc.viewport.zNear, 
		vc.viewport.zFar); 
		*/
	// ////////////////////////////////////////////////////////

	// /////////// Establish viewing volume: method2 //////////
	vc.viewVolume.left		= -2.0;
	vc.viewVolume.right		= +2.0;
	vc.viewVolume.bottom	= -2.0;
	vc.viewVolume.top		= +2.0;
	vc.viewVolume.zNear		= +0.5;		// must be positive
	vc.viewVolume.zFar		= +100.0;	// must be positive
	
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity ();
	glFrustum(
		vc.viewVolume.left,			
		vc.viewVolume.right,
		vc.viewVolume.bottom,	
		vc.viewVolume.top,		
		vc.viewVolume.zNear	,	
		vc.viewVolume.zFar);		
	// ////////////////////////////////////////////////////////
	
    

	// SET SOME OGL INITIAL STATES SO THEY ARE NOT DONE IN THE DRAW LOOP
	glMatrixMode(GL_MODELVIEW);
//	glPolygonMode(GL_FRONT,GL_FILL);
	glPolygonMode(GL_FRONT,GL_LINE);
	glDepthFunc(GL_LESS);
    glEnable(GL_CULL_FACE);
	glHint(GL_LINE_SMOOTH_HINT,GL_FASTEST);
	glDisable(GL_TEXTURE_2D);


	// lighting 	
	glMaterialfv(GL_FRONT,GL_DIFFUSE, diffuse);
	glMaterialfv(GL_FRONT,GL_SPECULAR, specular);
	glMaterialf(GL_FRONT,GL_SHININESS, 12.0f);
	glLightfv(GL_LIGHT0,GL_AMBIENT, ambient);
	glLightfv(GL_LIGHT0, GL_POSITION, lightpos);
	glDisable(GL_LIGHTING);
	glEnable(GL_LIGHT0);


   glClearColor (0.0, 0.0, 0.0, 0.0);
   glShadeModel (GL_SMOOTH);
   glEnable(GL_DEPTH_TEST); 
   glFrontFace(GL_CCW);

	vc.camera.pos.Set(0.0, 0.0, -3.0);
	vc.camera.rot.Set(340.0, 250.0, 0.0);
	vc.camera.at.Set(0.0, 0.0, 0.0);
	vc.camera.up.Set(0.0, 1.0, 0.0);
	vc.sampleId = 0;

	pause = 0;
}



// ///////////////////////////////////////////////////////////
// function: GLRender()
//
// creation date:	11/01/01
// last modified:	11/01/01
// purpose: render openGL scene
// arguments: visual context object
//
// return value: none
// ///////////////////////////////////////////////////////////

void GLRender(VisualContext& vc)
{
	if (vc.visualizer.GetBackgroundColor() == 0)
	{
		glClearColor (1.0, 1.0, 1.0, 0.0);
	}
	else if (vc.visualizer.GetBackgroundColor() == 1)
	{
		glClearColor (0.55, 0.55, 0.55, 0.0);
	}
	else if (vc.visualizer.GetBackgroundColor() == 2)
	{
		glClearColor (0.4, 0.4, 0.99, 0.0);
	}
	else 
	{
		glClearColor (0.0, 0.0, 0.0, 0.0);
	}

    glDisable(GL_DEPTH_TEST);	// TURN OFF DEPTH TEST FOR CLEAR

    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_CULL_FACE);
    glEnable(GL_DEPTH_TEST);

    glColor3f (1.0, 0.0, 0.0);  
    //glEnable(GL_COLOR_MATERIAL);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	glLoadIdentity();
	gluLookAt(vc.camera.pos.x, vc.camera.pos.y, vc.camera.pos.z, 
				vc.camera.at.x, vc.camera.at.y, vc.camera.at.z, 
				vc.camera.up.x, vc.camera.up.y, vc.camera.up.z);

    glRotatef(vc.camera.rot.x, 1, 0, 0);
    glRotatef(vc.camera.rot.y, 0, 1, 0);
    glRotatef(vc.camera.rot.z, 0, 0, 1);

	glPushMatrix();

	if (Vertex3::GetGlobalVertexCount() > 0)
	{
 	vc.visualizer.DrawMaxBox3(vc.box);
	vc.visualizer.DrawVoronoiCell(vc.sampleId);
	vc.visualizer.DrawDataSet3(vc.obj);
	vc.visualizer.DrawTetraList(vc.tetraList, 0);
	vc.visualizer.DrawSuperTetrahedron(vc.superTetra);
	vc.visualizer.DrawVertexNormals();
	vc.visualizer.DrawFaceNormals(vc.tetraList);

	vc.visualizer.DrawFaceArray((unsigned long *)vc.obj->faceIndex, (unsigned long)vc.obj->faceCount);

	vc.visualDebugger.VisualizeTetraList(vc.tetraList,  VISUAL_DEBUG_TETRA_ID); // VISUAL_DEBUG_TETRA_ID;
	}
	vc.visualizer.DrawGrid();
	vc.visualizer.DrawBackgroundPlane();  
	vc.visualizer.DrawCoordinateSystem();
	


	glPopMatrix();
}



// ///////////////////////////////////////////////////////////
// function: GLIdle()
//
// creation date:	11/01/01
// last modified:	11/01/01
// purpose: work to be done by OpenGL when the application loop
//          is idle: good for real-time graphics 
// arguments: visual context object
//
// return value: none
// ///////////////////////////////////////////////////////////

void GLIdle(VisualContext& vc)
{

	if (pause) { return; }
     
	/*
	if (!interactive) { return; }

	if (insertPoint > Vertex3::GetGlobalVertexCount()) return;

	if (insertPoint == 0)
	{
		// PHASE1: build super tetrahedron
		Tetrahedron *super;
		super = CreateSuperTetrahedron(Vertex3::GetGlobalVertexList(), Vertex3::GetGlobalVertexCount());
		tetraList.Add(super);
	#ifdef _DEBUG_STRICT
		int TETRALIST_SIZE_AFTER_SUPERTETRA_IS_NOT_POSITIVE = ((int)tetraList.Size()>0);
		assert(TETRALIST_SIZE_AFTER_SUPERTETRA_IS_NOT_POSITIVE);
	#endif
	}

	if (insertPoint < Vertex3::GetGlobalVertexCount())
	{
		// PHASE2: build Delaunay terahedralization
		// find ball-seeded tetrahedra
		list<Face3 *> tempFaceList;	
		FlagAndDeleteBallSeededTetrahedra(tetraList, insertPoint,  tempFaceList);	
		RetainSinglyOccurringFaces(tempFaceList);
		CreateTetrahedronFrom4FacesAndPoint(tempFaceList, insertPoint, tetraList);
	}

	if (insertPoint == Vertex3::GetGlobalVertexCount())
	{
		// PHASE3: eliminate boundary tetrahedra
		DeleteArbitraryBoundaryFaces(tetraList);

		// PHASE4: Voronoi tessellation
		BuildVoronoiTessellation(tetraList);
	}

	// advance to next reconstruction frame
	insertPoint++;

	display();
	*/
}



// ///////////////////////////////////////////////////////////
// function: GLResize()
//
// creation date:	11/01/01
// last modified:	11/01/01
// purpose: resize 
//          is idle: good for real-time graphics 
// arguments: visual context object
//
// return value: none
// ///////////////////////////////////////////////////////////

void GLResize(VisualContext& vc)
{
	glViewport (0, 0, vc.viewport.width, vc.viewport.height);
	
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity ();
	glFrustum(
		vc.viewVolume.left,			
		vc.viewVolume.right,
		vc.viewVolume.bottom,	
		vc.viewVolume.top,		
		vc.viewVolume.zNear	,	
		vc.viewVolume.zFar);	
	glMatrixMode(GL_MODELVIEW);
}




// ///////////////////////////////////////////////////////////
// function: ToggleGLIdlePause()
//
// creation date:	11/01/01
// last modified:	11/01/01
// purpose: pause/unpause the idle loop
//        
// arguments: visual context object
//
// return value: none
// ///////////////////////////////////////////////////////////

void ToggleGLIdlePause()
{
	pause = !pause;
}
// /////////////////////////////////////////////////
// geom.cpp
//
// author:			Aaron Licata
// creation date:	20/08/00
// last modified:	20/08/00
//
// Header file for all general geometrical data structures
// and procedures

#include "geom.h"



// ///////////////////////////////////////////////////////////
// function: Skeleton()
//
// creation date:	11/01/01
// last modified:	11/01/01
// purpose: constructor
// arguments: n/a
//
// return value: none
// ///////////////////////////////////////////////////////////

Skeleton::Skeleton()
{
	vert = 0;
	vertCount = 0;
	edge = 0;
	edgeCount = 0;
	face = 0;
	faceIndex = 0;
	faceCount = 0;
	tetra = 0;
	tetraCount = 0;
	mesh = 0;
	meshCount = 0;

}



// ///////////////////////////////////////////////////////////
// function: ~Skeleton()
//
// creation date:	11/01/01
// last modified:	11/01/01
// purpose: destructor
// arguments: n/a
//
// return value: none
// ///////////////////////////////////////////////////////////

Skeleton::~Skeleton()
{
	
	if (vert && vertCount > 0)
	{
	    delete [] vert;
	}

	
	if (faceIndex && faceCount > 0)
	{
		delete [] faceIndex;
	}

	if (face && faceCount > 0)
	{
		delete [] face;
	}
	
}
// /////////////////////////////////////////////////
// STL.h
//
// author:			Aaron Licata
// creation date:	14/09/00
// last modified:	14/09/00
//
// Header file to enable native STL in a portable way  
//
// Note: STL.h must be the last of the includes in a source file

#ifndef NATIVE_STL_H
#define NATIVE_STL_H

#include "config.h"

#ifdef WIN32
	#pragma warning(disable: 4786)
	using namespace std;
#endif

#ifdef LINUX	
// linux stl stuff
#endif

#ifdef SOLARIS	
// solaris stl stuff
#endif


#endif
// /////////////////////////////////////////////////
// visdebug.h
//
// author:			Aaron Licata
// creation date:	08/02/01
// last modified:	08/02/01
//
// Visualize the actual geometric data structres for 
// debugging purposes

#ifndef VISUAL_DEBUG_H
#define VISUAL_DEBUG_H

#define VISUAL_DEBUG_CENTER 1
#define VISUAL_DEBUG_TETRA_ID 2

#include "geom.h"
#include "geomutil.h"


// ////////////////////////////////////////////////////////////////
// class VisualDebug
//
// author:		Aaron Licata
// creation date:	30/08/00
// last modified:	22/04/01
//
// purpose: class to visualized the internals of geometrical
// data structure MTIN (Minimal Tetrahedralisation Network)
//
// /////////////////////////////////////////////////////////////////
class VisualDebug
{
public:
	// Visual Debugging
	VisualDebug();
	void VisualizeTetraList(TetraList& tetraList, int mode);
	void SetTetraListViewScale(float scale);
	float GetTetraListViewScale();
	bool IsVisible() { return isVisible; }
	void SetVisualizer(bool state) { isVisible = state; }

private:
	void VisualizeFaceNeigh(Vector3& pos, int faceId, Tetrahedron* tetra, Vector3& color, float xmax, float xmin, float ymax, float ymin, float yTetraTop);
	void VisualizeTetraNeigh(Vector3& pos, Tetrahedron* tetra, Vector3& color, float scale, int mode);
	void VisualizeTetrahedron(Tetrahedron* tetra, Vector3& pos, float tetraDim, int mode);
	void ChooseDebugColor(float& r, float& g, float& b, Tetrahedron *tetra, int mode);

private:
	float debugTetraListViewScale;
	bool isVisible;
};

#endif
// /////////////////////////////////////////////////
// visdebug.h
//
// author:			Aaron Licata
// creation date:	08/02/01
// last modified:	08/02/01
//
// Visualize the actual geometric data structres for 
// debugging purposes
#ifdef WIN32
	#include <windows.h>
#endif
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "config.h"
#include "math.h"
#include "geom.h"
#include "geomutil.h"
#include "geostat.h"
#include "appio.h"
#include "STL.h"
#include "visdebug.h"



// ///////////////////////////////////////////////////////////
// function: VisualDebug()
//
// creation date:	08/02/01
// last modified:	08/02/01
// purpose: constructor
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

VisualDebug::VisualDebug()
{
	debugTetraListViewScale = 3.0f;
	isVisible = false;
}



// ///////////////////////////////////////////////////////////
// function: SetTetraListViewScale()
//
// creation date:	08/02/01
// last modified:	18/03/01
// purpose: set zoom factor
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void VisualDebug::SetTetraListViewScale(float scale)
{
	debugTetraListViewScale = scale; 
}



// ///////////////////////////////////////////////////////////
// function: GetTetraListViewScale()
//
// creation date:	08/02/01
// last modified:	08/02/01
// purpose: get zoom factor
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

float VisualDebug::GetTetraListViewScale()
{
	return debugTetraListViewScale;
}




// ///////////////////////////////////////////////////////////
// function: ChooseDebugColor()
//
// creation date:	03/01/01
// last modified:	03/01/01
// purpose: choose debug color
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void VisualDebug::ChooseDebugColor(float& r, float& g, float& b, Tetrahedron *tetra, int mode)
{
//int max = Tetrahedron::GetCurrentID();
Vertex3 center;
double dist;
		
r = g = b = 0.5;

	switch (mode) 
	{

		case VISUAL_DEBUG_CENTER:	
			center = tetra->Centre();
			dist = center.x*center.x+center.y*center.y+center.z*center.z;
			if (sqrt(dist)< 1.0)
			{
				r = center.x;
				b = center.y;
				g = center.z;
			}
			else
			{
				r = g = b = 0.5;
			}
			break;

		case VISUAL_DEBUG_TETRA_ID:
			int max = Tetrahedron::GetCurrentID();
			float shade = ((float)tetra->GetID())/((float)max);
			r = g = b = shade*shade;
			
			break;
			
		//default:
		 //  r = b = g = 0.5;
		//	break;
	}
}



// ///////////////////////////////////////////////////////////
// function: VisualizeTetraList()
//
// creation date:	03/01/01
// creation date:	03/01/01
// purpose: visualize tetralist
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void VisualDebug::VisualizeTetraList(TetraList& tetraList, int mode)
{
	if (!IsVisible())
	{
		return;
	}

	TetraList::Itr startIter;
	TetraList::Itr endIter;
	
	startIter = tetraList.Begin();
	endIter = tetraList.End();
	int totalTetras = tetraList.Size();

	// we might switch to a different projection martrix, etc...
	glPushMatrix();
	/*
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
   glFrustum(-1.0, 1.0, -1.0, 1.0, 30.0f, 100.0f); 
   glMatrixMode(GL_MODELVIEW);
   glRotatef(0.0f, 1.0f, 0.0f, +270.0f);
   */

	// scale down each tetrahedron so that they can fit in the unit cube
	float scale = debugTetraListViewScale *(float)(1.0f/((float)totalTetras));

	int ith = 0;

	for (; startIter != endIter; startIter++)
	{
		Tetrahedron *tetra = *startIter;

		// distribute tetraheda evenly around the origin
		float param = float((float)ith++/(float)totalTetras); // param in range 0-1
		Vector3 position;
		// create a position vector from -0.5 to +0.5 range
		position.x =  debugTetraListViewScale * 10.0 *(param - 0.5f); 
		position.y = position.z = 0.0f;
#ifdef _DEBUG_STRICT
		assert(tetra != NULL);
#endif
		VisualizeTetrahedron(tetra, position, scale, mode);
	}

	glPopMatrix();
}



// ///////////////////////////////////////////////////////////
// function: VisualizeFaceNeigh()
//
// creation date:	01/09/00
// last modified:	03/10/00
// purpose: visualizer neighbours
//
// arguments: positionl, face id, tetrahedron
//
// return value: none
// ///////////////////////////////////////////////////////////

void VisualDebug::VisualizeFaceNeigh(Vector3& pos, int faceId, Tetrahedron* tetra, Vector3& color, float xmax, float xmin, float ymax, float ymin, float yTetraTop)
{

	float r = color.x;
	float g = color.y;
	float b = color.z;
	
	float midx = (xmax + xmin)/2.0f;

	glPushMatrix();
	glTranslatef(pos.x, pos.y, pos.z);
	glLineWidth(1.7f);
    glBegin(GL_QUADS);
		glColor3f(r-0.1f, g-0.1f, b-0.1f); 
		glVertex3f(xmin, ymax, 0.0f);
		glColor3f(r-0.0f, g-0.0f, b-0.0f); 
		glVertex3f(xmax, ymax, 0.0f);
		glColor3f(r+0.01f, g+0.01f, b+0.01f); 
		glVertex3f(xmax, ymin, 0.0f);
		glColor3f(r+0.1f, g+0.1f, b+0.1f); 
		glVertex3f(xmin, ymin, 0.0f);
	glEnd();
	// bottom arrow 
	glLineWidth(1.0f);
	glBegin(GL_LINES);
		glColor3f(0.9f, 0.9f, 0.9f);
		glVertex3f(midx, yTetraTop, 0.0f);
		glVertex3f(midx, ymin, 0.0f);
	glEnd();
	// top arrow towards neigh 
#ifdef _DEBUG_STRICT
	assert(tetra->F(faceId) != NULL);
#endif
	glBegin(GL_LINES);
		if (tetra->F(faceId)->neigh) // got neighbour: red and long
		{
			glLineWidth(1.3f);
			glColor3f(1.0f, 0.0f, 0.0f);
			glVertex3f(midx, ymax, 0.0f);
			glVertex3f(midx, ymax+(ymax-ymin), 0.0f);
		}
		else // no neighbour: gray and short
		{
			glLineWidth(1.0f);
			glColor3f(0.4f, 0.4f, 0.4f);
			glVertex3f(midx, ymax, 0.0f);
			glVertex3f(midx, ymax+(ymax-ymin)/2, 0.0f);
		}
	glEnd();
	// link to neibouring tetrahedron
	// draw a link from face pointer to ceter of neigh tetra
	if (tetra->F(faceId)->neigh)
	{
		glBegin(GL_LINES);
			glLineWidth(1.3f);
			glColor3f(1.0f, 0.0f, 0.0f);
			glVertex3f(midx, ymax+(ymax-ymin), 0.0f);
			float shade = (float)tetra->F(faceId)->neigh->GetID()
				/ (float)(Tetrahedron::GetCurrentID());
			glColor3f(1.0f, shade, shade);
			Vertex3 c = tetra->F(faceId)->neigh->Centre();
			glVertex3f(c.x, c.y, c.z);
		glEnd();
			glPopMatrix();
	}
	else // no link (external face?)
	{
			glPopMatrix();
		glPushMatrix();
		glPointSize(6.0);
		glBegin(GL_POINTS);
			glColor3f(0.0f, 1.0f, 0.3f);
			glVertex3f(midx, ymax+(ymax-ymin), 0.0f);
		glEnd();
		glPopMatrix();
	}	

}



// ///////////////////////////////////////////////////////////
// function: VisualizeTetraNeigh()
//
// creation date:	01/09/00
// last modified:	03/10/00
// purpose: visualize tetrahedron neighbour
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void VisualDebug::VisualizeTetraNeigh(Vector3& pos, Tetrahedron* tetra, Vector3& color, float scale, int mode)
{


	float xmax;
	float xmin;
	float ymax = +0.9f;
	float ymin = +0.6f;
	float yTetraTop = +0.5;
	int faceId;

	// overwrite color
	color.x = 0.6;
	color.y = 0.6;
	color.z = 0.6;


	// face 0 (left)
	xmax = -0.2f;
	xmin = -0.4f;
	faceId = 0;
	VisualizeFaceNeigh(pos, faceId, tetra, color, xmax, xmin, ymax, ymin, yTetraTop);
	// face 1 (center left)
	xmax = -0.0f;
	xmin = -0.2f;
	faceId = 1;
	VisualizeFaceNeigh(pos, faceId, tetra, color, xmax, xmin, ymax, ymin, yTetraTop);
	// face 2 (center right)
	xmax = +0.2f;
	xmin = +0.0f;
	faceId = 2;
	VisualizeFaceNeigh(pos, faceId, tetra, color, xmax, xmin, ymax, ymin, yTetraTop);
	// face 3 (right)
	xmax = +0.4f;
	xmin = +0.2f;
	faceId = 3;
	VisualizeFaceNeigh(pos, faceId, tetra, color, xmax, xmin, ymax, ymin, yTetraTop);
}



// ///////////////////////////////////////////////////////////
// function: VisualizeTetrahedron()
//
// creation date:	01/09/00
// last modified:	03/10/00
// purpose: visualize tetrahedron
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

void VisualDebug::VisualizeTetrahedron(Tetrahedron* tetra, Vector3& pos, float tetraDim, int mode)
{
	glPushMatrix();

	glTranslatef(pos.x, pos.y, pos.z);
	glScalef(tetraDim, tetraDim, tetraDim);

	glPolygonMode(GL_FRONT,GL_FILL);
	glPolygonMode(GL_BACK,GL_FILL);
	glDisable(GL_CULL_FACE);
	glLineWidth(2.0);

	float r, g, b;

	ChooseDebugColor(r, g, b, tetra, mode);

	glBegin(GL_QUADS);
		glColor3f(r-0.1f, g-0.1f, b-0.1f); 
		glVertex3f(-0.5f, +0.5f, 0.0f);
		glColor3f(r-0.0f, g-0.0f, b-0.0f); 
		glVertex3f(+0.5f, +0.5f, 0.0f);
		glColor3f(r+0.01f, g+0.01f, b+0.01f); 
		glVertex3f(+0.5f, -0.5f, 0.0f);
		glColor3f(r+0.1f, g+0.1f, b+0.1f); 
		glVertex3f(-0.5f, -0.5f, 0.0f);
	glEnd();

	float neighScale = 1.0;
	Vector3 color;

	color.x = r;
	color.y = g;
	color.z = b; 
	glPopMatrix();
	VisualizeTetraNeigh(pos, tetra, color, neighScale, mode);

	glEnable(GL_CULL_FACE);
}


// /////////////////////////////////////////////////
// visualize.h
//
// author:			Aaron Licata
// creation date:	01/02/01
// last modified:	01/02/01
//
// Visualize the geometrical structres 
//

#ifndef VISUALIZE_GEOMETRY_H
#define VISUALIZE_GEOMETRY_H

#include "config.h"
#include "math.h"
#include "geom.h"
#include "geomutil.h"

const int GV_POINTS = 0;
const int GV_WIRE = 1;
const int GV_FLATSOLID = 2;
const int GV_SMOOTHSHADING = 4;
const int GV_WIREANDSHADE = 8;


// ////////////////////////////////////////////////////////////////
// class GeometryVisualizer 
//
// author:		Aaron Licata
// creation date:	30/01/01
// last modified:	22/04/01
//
// purpose: opengl visualisation module
//
// /////////////////////////////////////////////////////////////////

class GeometryVisualizer 
{
public:
	GeometryVisualizer();
	void DrawMaxBox3(BoundBox3& box);
	void DrawTetrahedron(Tetrahedron *tetra, int mode);
	void DrawWireTetrahedron(Tetrahedron *tetra);
	void DrawShadedTetrahedron(Tetrahedron *tetra);
	void DrawSuperTetrahedron(SuperTetra &superTetra);
	void DrawVoronoi(Tetrahedron *tetra, int mode);
	void DrawVoronoiCell(int pointIndex);
	void DrawTetraList(TetraList& tetraList, int mode);
	void DrawCircumSphere(Tetrahedron* tetra);
	void DrawDataSet3(Skeleton *obj);
	void DrawVertexNormal(int vertexId);
	void DrawVertexNormals();
	void DrawFaceNormal(Face3 *face);
	void DrawFaceNormals(TetraList& tetraList);
	void DrawFaceArray(unsigned long *faceArray, long faceCount);
	void DrawWireFaceArray(unsigned long *faceArray, long faceCount);
	void DrawShadedFaceArray(unsigned long *faceArray, long faceCount);

	void DrawGrid();
	void DrawBackgroundPlane();
	void DrawCoordinateSystem();
	void DrawBackground();

	void SetMaxSquareRadius(double m) { maxSquareRadius = m; }
	void SetAlphaShapeParameter(double dRadius) { alphaSquareRadius = dRadius; }
	double GetMaxSquareRadius() { return maxSquareRadius; }

	bool IsVisibleMaxBox3() { return isVisibleMaxBox3; }
	bool IsVisibleSemiArbitraryFaces() { return isVisibleSemiArbitraryFaces;}
	bool IsVoronoiCenterVisible() { return isVoronoiCenterVisible; }
	bool IsVisibleTetrahedra() { return isVisibleTetrahedra;}
	bool IsVisibleSuperTetrahedron() { return isVisibleSuperTetra; }
	bool IsVisibleVoronoi() { return isVisibleVoronoi;}
	bool IsVisibleVoronoiVertex() {return isVisibleVoronoiVertex;}
	bool IsVisibleDataSet3() { return isVisibleDataSet3; }
	bool IsVisibleVoronoiCell() {return isVisibleVoronoiCell;}
	bool IsVisibleOnlyConvexHull() { return isVisibleOnlyConvexHull; }
	bool IsVisibleCircumSphere() { return isVisibleCircumSphere; }
	bool IsVisibleVertexNormal() { return isVisibleVertexNormal; }

	bool IsVisibleFaceNormal() { return isVisibleFaceNormal; }

	bool IsVisibleBackgroundPlane() { return isVisibleBackgroundPlane; }
	bool IsVisibleGrid() { return isVisibleGrid; }
	bool IsVisibleBackground() { return isVisibleBackground; }
	bool IsVisibleCoordinateSystem() { return isVisibleCoordinateSystem; }
	bool IsVisibleLighting() { return isVisibleLighting; }

	void SetVisibleMaxBox3(bool state) { isVisibleMaxBox3 = state; }
	void SetVisibleSemiArbitraryFaces(bool state) { isVisibleSemiArbitraryFaces = state;}
	void SetVoronoiCenterVisible(bool state) { isVoronoiCenterVisible = state; }
	void SetVisibleTetrahedra(bool state) { isVisibleTetrahedra = state;}
	void SetVisibleSuperTetrahedron(bool state) { isVisibleSuperTetra = state; }
	void SetVisibleVoronoi(bool state) { isVisibleVoronoi = state;}
	void SetVisibleVoronoiVertex(bool state) { isVisibleVoronoiVertex = state; }
	void SetVisibleDataSet3(bool state) { isVisibleDataSet3 = state; }
	void SetVisibleVoronoiCell(bool state) { isVisibleVoronoiCell = state; }
	void SetVisibleOnlyConvexHull(bool state) { isVisibleOnlyConvexHull = state; }
	void SetVisibleCircumSphere(bool state) { isVisibleCircumSphere = state ; }
	void SetVisibleVertexNormal(bool state) { isVisibleVertexNormal = state ; }
	void SetVisibleFaceNormal(bool state) { isVisibleFaceNormal = state; }

	void SetVisibleGrid(bool state) { isVisibleGrid = state; }
	void SetVisibleBackground(bool state) { isVisibleBackground = state; }
	void SetVisibleCoordinateSystem(bool state) { isVisibleCoordinateSystem = state; }
	void SetVisibleBackgroundPlane(bool state) { isVisibleBackgroundPlane = state; }
	void SetVisibleLighting(bool state) { isVisibleLighting = state; }

	void SetBackgroundColor(int selection) { backgroundColor = selection;}
	void SetPolygonMode(int mode) { polygonMode = mode; }
	void SetAlphaParamDirection(int dir) { alphaParamDirection = dir; }
	void SetBottomOfBox(double b) { bottomOfBox = b; }
	void SetNormalFactor(double factor) { normalFactor = factor; }

	int GetBackgroundColor() { return backgroundColor; }
	int GetPolygonMode() { return polygonMode; }
	int GetAlphaParamDirection() { return alphaParamDirection; }
	double GetBottomOfBox() { return bottomOfBox; }
	double GetNormalFactor() { return normalFactor; }

	void InitializeContext();

private:
	bool isVisibleMaxBox3;
	bool isVisibleSemiArbitraryFaces;
	bool isVoronoiCenterVisible;
	bool isVisibleTetrahedra;
	bool isVisibleSuperTetra;
	bool isVisibleVoronoi;
	bool isVisibleVoronoiVertex;
	bool isVisibleMaxBox;
	bool isVisibleDataSet3;
	bool isVisibleVoronoiCell;
	bool isVisibleOnlyConvexHull;
	bool isVisibleCircumSphere;
	bool isVisibleVertexNormal;
	bool isVisibleFaceNormal;

	bool isVisibleBackground;
	bool isVisibleGrid;
	bool isVisibleCoordinateSystem;
	bool isVisibleBackgroundPlane;
	bool isVisibleLighting;

	int polygonMode;

	int alphaParamDirection;
	double maxSquareRadius; 
	double alphaSquareRadius;
	double normalFactor;
	int backgroundColor;

	double bottomOfBox;
};


bool IsSuperVertex(Face3 *f);
bool IsTouchingSuperVertices(Face3 *f);

#endif

// /////////////////////////////////////////////////
// visualize.cpp
//
// author:			Aaron Licata
// creation date:	01/02/01
// last modified:	01/02/01
//
// Visualize the geometrical structres 
//
#ifdef WIN32
	#include <windows.h>
#endif

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "math.h"
#include "geom.h"
#include "geomutil.h"
#include "geostat.h"
#include "appio.h"
#include "STL.h"
#include "visualize.h"
#include "crust.h"

const int OGL_GRID_DLIST = 1;
const int OGL_COORDINATE_SYSTEM_DLIST = 2;



// ///////////////////////////////////////////////////////////
// function: GeometryVisualizer()
//
// creation date:	11/11/00
// last modified:	14/04/01
// purpose: constructor
//
// arguments: box is the 3-d object to be drawn
// ///////////////////////////////////////////////////////////

GeometryVisualizer::GeometryVisualizer()
{
	isVisibleMaxBox3 = false;
	isVisibleSemiArbitraryFaces = true;
	isVoronoiCenterVisible = true;
	isVisibleTetrahedra = true;
	isVisibleVoronoi = true;
	isVisibleMaxBox = false;
	isVisibleDataSet3 = true;
	isVisibleVoronoiCell = false;
	isVisibleOnlyConvexHull = false;
	isVisibleVoronoiVertex = false;
	isVisibleCircumSphere = false;
	isVisibleVertexNormal = false;
	isVisibleFaceNormal = true;

	isVisibleGrid = true;
	isVisibleBackground = true;
	isVisibleCoordinateSystem = true;

	maxSquareRadius = 100.00;
	alphaSquareRadius = 100.0;
	alphaParamDirection = 0;
	polygonMode = GV_SMOOTHSHADING;

	backgroundColor = 1;

	// overwrite defaults
	isVisibleMaxBox3 = false;
	isVisibleSemiArbitraryFaces = false;
	isVoronoiCenterVisible = true;
	isVisibleTetrahedra = true;
	isVisibleVoronoi = false;
	isVisibleMaxBox = false;
	isVisibleDataSet3 = false;
	isVisibleVoronoiCell = false;
	isVisibleOnlyConvexHull = true;
	isVisibleVoronoiVertex = false;
	isVisibleVertexNormal = false;

	isVisibleSuperTetra = false;

	isVisibleGrid = false;
	isVisibleBackgroundPlane = true;
	isVisibleLighting = false;

	normalFactor = 0.2;


	bottomOfBox = 0.0;

	// display list for 
	
}


// ///////////////////////////////////////////////////////////
// function: DrawMaxBox3()
//
// creation date:	11/11/00
// last modified:	13/02/01
// purpose: draw a 3-d box 
//
// arguments: box is the 3-d object to be drawn
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawMaxBox3(BoundBox3& box)
{
	if (!IsVisibleMaxBox3()) return;

	double sx = box.MaxX() - box.MinX();
	double sy = box.MaxY() - box.MinY();
	double sz = box.MaxZ() - box.MinZ();

	glPushMatrix();
		glLineWidth(0.5);


		// front face
		glBegin(GL_LINE_LOOP);
			glColor3f(0.99, 1.0, 0.99);
		    glVertex3f(box.MinX(), box.MaxY(), box.MinZ());

			glColor3f(0.72, 0.72, 0.73);
			glVertex3f(box.MaxX(), box.MaxY(), box.MinZ());

			glColor3f(0.90, 0.90, 0.90);
			glVertex3f(box.MaxX(), box.MinY(), box.MinZ());

			glColor3f(0.83, 0.82, 0.83);
			glVertex3f(box.MinX(), box.MinY(), box.MinZ());
		glEnd();

		// back face
		glBegin(GL_LINE_LOOP);
			glColor3f(0.87, 0.86, 0.86);
			glVertex3f(box.MinX(), box.MaxY(), box.MaxZ());

			glColor3f(0.99, 0.99, 0.98);
			glVertex3f(box.MaxX(), box.MaxY(), box.MaxZ());

			glColor3f(0.71, 0.71, 0.72);
			glVertex3f(box.MaxX(), box.MinY(), box.MaxZ());

			glColor3f(0.80, 0.80, 0.80);
			glVertex3f(box.MinX(), box.MinY(), box.MaxZ());
		glEnd();

		//left face
		glBegin(GL_LINE_LOOP);
		    glVertex3f(box.MinX(), box.MaxY(), box.MinZ());
			glVertex3f(box.MinX(), box.MaxY(), box.MaxZ());
			glVertex3f(box.MinX(), box.MinY(), box.MaxZ());
			glVertex3f(box.MinX(), box.MinY(), box.MinZ());
		glEnd();

	
		//right face
		glBegin(GL_LINE_LOOP);
		    glVertex3f(box.MaxX(), box.MaxY(), box.MinZ());
			glVertex3f(box.MaxX(), box.MaxY(), box.MaxZ());
			glVertex3f(box.MaxX(), box.MinY(), box.MaxZ());
			glVertex3f(box.MaxX(), box.MinY(), box.MinZ());
		glEnd();

		//top face
		glBegin(GL_LINE_LOOP);
		    glVertex3f(box.MinX(), box.MaxY(), box.MinZ());
			glVertex3f(box.MinX(), box.MaxY(), box.MaxZ());
			glVertex3f(box.MaxX(), box.MaxY(), box.MaxZ());
			glVertex3f(box.MaxX(), box.MaxY(), box.MinZ());
		glEnd();
		
	glPopMatrix();
}


// ///////////////////////////////////////////////////////////
// function: DrawTetrahedron()
//
// creation date:	15/11/00
// last modified:	10/01/01
// purpose: draw a 3-d box 
//
// arguments: tetra is the tetrahedron object to draw 
//            mode flag specifies if solid or wire drawing mode
//
// notes: flag mode is tightly coupled to OpenGL API
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawTetrahedron(Tetrahedron *tetra, int mode2)
{
	int mode = GetPolygonMode();

	if (mode == GV_SMOOTHSHADING || mode == GV_FLATSOLID || mode == GV_WIREANDSHADE)
	{
		DrawShadedTetrahedron(tetra);
	}

	if (mode == GV_WIRE || mode == GV_WIREANDSHADE)
	{
		DrawWireTetrahedron(tetra);
	}


}




// ///////////////////////////////////////////////////////////
// function: DrawShadedTetrahedron()
//
// creation date:	29/11/01
// last modified:	29/11/01
// purpose: draw a tetrahedron in shaded mode
//
// arguments: tetra is the tetrahedron object to draw           
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawShadedTetrahedron(Tetrahedron *tetra)	
{
	Face3 *f;
	float c[3] = {0.5, 0.5, 0.9 };

	// do not show tetrahedra larger than of alpha shape values
	if (alphaParamDirection)
	{
		if (tetra->SquareRadius() <  alphaSquareRadius) return;
	}
	else
	{
		if (tetra->SquareRadius() >  alphaSquareRadius) return;
	}

	// ///////////////////// opengl ////////////////////////
	glPushMatrix();


	glColor3f(1.0, 1.0, 1.0);


	glDisable(GL_CULL_FACE);
	//glDisable(GL_DEPTH_TEST);

	if (IsVisibleLighting())
	{
		glEnable(GL_LIGHTING);
	}
	else
	{
		glDisable(GL_LIGHTING);
	}


	for (int i = 0; i < 4; i++)
	{
		f = tetra->F(i);

		if (IsVisibleOnlyConvexHull())
		if (f->neigh != NO_LINK) // show only convex-hull
			continue;

		// triangle must be on the crust
		if (f->V(0)->IsPole() || (f->V(1)->IsPole()) || (f->V(2)->IsPole()))
		{
			continue;
		}

				// solid mode
		if (GetPolygonMode() == GV_FLATSOLID 
			|| GetPolygonMode() == GV_SMOOTHSHADING
			|| GetPolygonMode() == GV_WIREANDSHADE)
		{
			glPolygonMode(GL_BACK, GL_FILL);
			glPolygonMode(GL_FRONT, GL_FILL);
		}
		else
		{
			int ERROR_NONEXISTING_RENDERING = 0;
			assert(ERROR_NONEXISTING_RENDERING);
		}


		glLineWidth(1.5);


			//glEnable(GL_NORMALIZE);
			glBegin(GL_TRIANGLES);
				GLfloat c1, c2 ,c3;
				GLfloat coff = 0.08; //color offset
				if (GetPolygonMode() == GV_FLATSOLID)
				{
					c1 = c2 = c3 = 0.70;
				}
				else
				{
					if (GetPolygonMode() == GV_SMOOTHSHADING)
					{
						c1 = 0.65;
						c2 = 0.60;
						c3 = 0.55;
					}
					else // wire and shade
					{
						c1 = 0.89;
						c2 = 0.70;
						c3 = 0.56;
					}
				}


				// /////// triangle 0 //////////
				glColor3f(c1+coff, c1, c1);
				glNormal3f(f->V(0)->normal.x, f->V(0)->normal.y, f->V(0)->normal.z);
				glVertex3f(f->V(0)->x, f->V(0)->y, f->V(0)->z);
				/////////////////////////////////


				// /////// triangle 1 //////////
				glColor3f(c2, c2, c2);
				glNormal3f(f->V(1)->normal.x, f->V(1)->normal.y, f->V(1)->normal.z);			
				glVertex3f(f->V(1)->x, f->V(1)->y, f->V(1)->z);
				/////////////////////////////////


				// //////// triangle 2 /////////
				glColor3f(c3, c3, c3+coff);
				glNormal3f(f->V(2)->normal.x, f->V(2)->normal.y, f->V(2)->normal.z);
				glVertex3f(f->V(2)->x, f->V(2)->y, f->V(2)->z);
				/////////////////////////////////

			glEnd();
			
	}

	glEnable(GL_CULL_FACE);
	//glEnable(GL_DEPTH_TEST);
	
	glDisable(GL_LIGHTING);


	glPopMatrix();
	///////////////////////// end of opengl /////////////////
	
}



// ///////////////////////////////////////////////////////////
// function: :DrawSuperTetrahedron()
//
// creation date:	23/04/01
// last modified:	23/04/01
// purpose: draw a super tetrahedron in wire mode
//
// arguments: super tetra is the tetrahedron object to draw           
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawSuperTetrahedron(SuperTetra &superTetra)
{
	
	if (!IsVisibleSuperTetrahedron())
	{
		return;
	}
	

	Vertex3 apex = superTetra.GetApex();
	Vertex3 left = superTetra.GetBaseLeft();
	Vertex3 right = superTetra.GetBaseRight();
	Vertex3 back = superTetra.GetBaseBack();


	glPushMatrix();

	glDisable(GL_CULL_FACE);

	glPolygonMode(GL_BACK, GL_LINE);
	glPolygonMode(GL_FRONT, GL_LINE);

	glLineWidth(3.0);

	GLfloat delta = 0.1;
	GLfloat r = 0.5-delta;
	GLfloat g = 0.5-delta;
	GLfloat b = 0.9-delta;

	// /////// triangle 0: front //////////
	glBegin(GL_TRIANGLES);
		glColor3f(r+delta, g-delta, b+delta);
		glVertex3f(apex.x, apex.y, apex.z);
		glColor3f(r-delta, g-delta, b+delta);
		glVertex3f(right.x, right.y, right.z);
		glColor3f(r-delta, g-delta, b+delta);
		glVertex3f(left.x, left.y, left.z);
	glEnd();

	// /////// triangle 1: right  //////////
	glBegin(GL_TRIANGLES);
		glColor3f(r, g+delta, b+delta);
		glVertex3f(apex.x, apex.y, apex.z);
		glColor3f(r+delta, g-delta, b+delta);
		glVertex3f(back.x, back.y, back.z);
		glColor3f(r-delta, g-delta, b+delta);
		glVertex3f(right.x, right.y, right.z);
	glEnd();
	
	// /////// triangle 2: left //////////
	glBegin(GL_TRIANGLES);
		glColor3f(r-delta, g-delta, b+delta);
		glVertex3f(apex.x, apex.y, apex.z);
		glColor3f(r+delta, g-delta, b+delta);
		glVertex3f(left.x, left.y, left.z);
		glColor3f(r+delta, g+delta, b+delta);
		glVertex3f(back.x, back.y, back.z);
	glEnd();

	// /////// triangle 3: bottom //////////
	glBegin(GL_TRIANGLES);
		glColor3f(r, g, b);
		glVertex3f(back.x, back.y, back.z);
		glVertex3f(left.x, left.y, left.z);
		glVertex3f(right.x, right.y, right.z);
	glEnd();


	glEnable(GL_CULL_FACE);

	glPopMatrix();



}


// ///////////////////////////////////////////////////////////
// function: DrawWireTetrahedron()
//
// creation date:	29/11/01
// last modified:	29/11/01
// purpose: draw a tetrahedron in wire mode
//
// arguments: tetra is the tetrahedron object to draw           
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawWireTetrahedron(Tetrahedron *tetra)	
{
	Face3 *f;
	float c[3] = {0.5, 0.5, 0.9 };

	// do not show tetrahedra larger than of alpha shape values
	if (alphaParamDirection)
	{
		if (tetra->SquareRadius() <  alphaSquareRadius) return;
	}
	else
	{
		if (tetra->SquareRadius() >  alphaSquareRadius) return;
	}

	glColor3f(1.0, 1.0, 1.0);


	/*
	if (GetPolygonMode() == GV_POINTS)
	{
		if (!IsVisibleDataSet3()) 
		{
			SetVisibleDataSet3(true);
		}
		else
		{
			return;
		}

		return;
	}*/

	// ////////////////// opengl //////////////////
	glPushMatrix();

	glDisable(GL_CULL_FACE);
	//glDisable(GL_DEPTH_TEST);
	for (int i = 0; i < 4; i++)
	{
		f = tetra->F(i);

		if (IsVisibleOnlyConvexHull())
		if (f->neigh != NO_LINK) // show only convex-hull
			continue;

		// wire mode
		if (GetPolygonMode() == GV_WIRE || GetPolygonMode() == GV_WIREANDSHADE)
		{
			glPolygonMode(GL_BACK, GL_LINE);
			glPolygonMode(GL_FRONT, GL_LINE);
		}
		else
		{
			int ERROR_NON_ALLOWED_RENDERING = 0;
			assert(ERROR_NON_ALLOWED_RENDERING);
		}

		
		glLineWidth(1.9);


			//glEnable(GL_NORMALIZE);
			glBegin(GL_TRIANGLES);

			// /////// triangle 0 //////////
			GLfloat r = 0.9f;
			GLfloat g = 0.0f;
			GLfloat b = 0.25f;
			GLfloat off = 0.1f;
			GLfloat delta = 0.2;

				glColor3f(r-delta, g, b+off-delta);
				glVertex3f(f->V(0)->x, f->V(0)->y, f->V(0)->z);
				// /////// triangle 1 //////////
				glColor3f(r, g, b+off);
				glVertex3f(f->V(1)->x, f->V(1)->y, f->V(1)->z);
				// //////// triangle 2 /////////
				glColor3f(r, g, b+2*off);
				glVertex3f(f->V(2)->x, f->V(2)->y, f->V(2)->z);
			glEnd();
	}

	glPopMatrix();
	////////////// end of opengl ///////////////////////////
	
}

// ///////////////////////////////////////////////////////////
// function: DrawVoronoi()
//
// creation date:	07/02/01
// last modified:	09/02/01
// purpose: draw the Voronoi 3-d diagram
//
// arguments: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawVoronoi(Tetrahedron *tetra, int mode)
{
	//glDisable(GL_CULL_FACE);
	//glDisable(GL_DEPTH_TEST);

		glLineWidth(1.0);
		glPointSize(3.5);

		//ShowTetraStatistics(tetra);

       	if (IsVisibleVoronoiVertex())
		{
			if (tetra->Centre().pole)
			{
				glColor3f(0.2, 0.105, 1.0);
			}
			else
			{
				glColor3f(1.0, 0.005, 0.2);
			}
			glBegin(GL_POINTS);
					glVertex3f(
						tetra->Centre().x,
						tetra->Centre().y,
						tetra->Centre().z);
			glEnd();
		}
	
		bool infinite = 
			(tetra->F(0)->neigh!=NO_LINK) && 
			(tetra->F(1)->neigh!=NO_LINK) &&
			(tetra->F(2)->neigh!=NO_LINK) &&
			(tetra->F(3)->neigh!=NO_LINK);
		
	if (IsVisibleVoronoi())
		for (int i = 0; i < 4; i++)
		{
			Face3 *face = tetra->F(i);
			Tetrahedron *neigh = face->neigh;
			if (neigh != NO_LINK)
			{
			
				glBegin(GL_LINES);
					glColor3f(0.90, 0.71, 0.01);
					glVertex3f(tetra->Centre().x, tetra->Centre().y, tetra->Centre().z);
					glColor3f(1.00, 0.41, 0.05);
					glVertex3f(neigh->Centre().x, neigh->Centre().y, neigh->Centre().z);
				glEnd();
				
			}
			else  // voronoi edge/plane to infinity
			{
				/*
				Vertex3 *v0 = face->V(0);
				Vertex3 *v1 = face->V(1);
				Vertex3 *v2 = face->V(2);
				Vertex3 m;
				m.x = (v0->x+v2->x)/2;
				m.y = (v0->y+v2->y)/2;
				m.y = (v0->z+v2->z)/2;
				glBegin(GL_LINES);
					glColor3f(0.00, 0.87, 0.01);
					glVertex3f(tetra->Centre().x, tetra->Centre().y, tetra->Centre().z);
					glColor3f(0.00, 0.66, 0.02);
					glVertex3f(m.x, m.y, m.z);
				glEnd();
				*/
			}
		}

		if (IsVisibleVoronoiVertex())
		{
			glPushMatrix();
			glPointSize(6.0);
			glBegin(GL_POINTS);
				glColor3f(0.3, 0.0, 0.05);
				glVertex3f(tetra->Centre().x, tetra->Centre().y, tetra->Centre().z);
			glEnd();
			glPopMatrix();
		}
		
/*		
    for (int i = 0; i < 4; i++)
	{
		f = tetra->F(i);

		glLineWidth(1.0);
		glPointSize(2.0);

		// draw tetra center (voronoi vertex)
		if (isVoronoiCenterVisible)
		{
			glColor3f(1.0, 0.0, 0.0);
			glBegin(GL_POINTS);
				glVertex3f(
					tetra->Centre().x,
					tetra->Centre().y,
					tetra->Centre().z);
			glEnd();
		}

		Tetrahedron *neigh = f->neigh;


		if (neigh != NO_LINK)
		{
			glBegin(GL_LINES);
				glColor3f(1.00, 0.61, 0.01);
				glVertex3f(tetra->Centre().x, tetra->Centre().y, tetra->Centre().z);
				glColor3f(1.00, 0.21, 0.05);
				glVertex3f(neigh->Centre().x, neigh->Centre().y, neigh->Centre().z);
			glEnd();
		}
		else
		{
			//AppOutN("NO_LINK");
		}

	
		//glDisable(GL_NORMALIZE);
	
	}
	*/
	
}


void GeometryVisualizer::DrawTetraList(TetraList& tetraList, int mode)
{
	TetraList::Itr startIter;
	TetraList::Itr endIter;
	
	startIter = tetraList.Begin();
	endIter = tetraList.End();
	int size = tetraList.Size();

	for (; startIter != endIter; startIter++)
	{
		Tetrahedron *tetra = *startIter;

		if (tetra->SquareRadius() < maxSquareRadius)
		{
			if (isVisibleTetrahedra)
			{
				DrawTetrahedron(tetra, mode);
			}
			DrawVoronoi(tetra, mode);
			DrawCircumSphere(tetra);
		}
	}
}

void GeometryVisualizer::DrawCircumSphere(Tetrahedron* tetra)
{
	if (!IsVisibleCircumSphere()) return;

   GLint slices = 19;
   GLint stacks = 20;
   GLfloat alpha = 0.074;
   double maxRadius = 0.3;
   double radius = sqrt(tetra->SquareRadius());


   //if (radius > maxRadius) return;

	glPushMatrix();

	glEnable(GL_BLEND);
	glTranslatef(tetra->Centre().x, tetra->Centre().y, tetra->Centre().z);
	if (radius < maxRadius)
	{
		glColor4f(0.9, 0.0, 0.5, alpha);
	}
	else
	{
		glColor4f(0.1, 0.0, 0.9, alpha);
	}
	glutSolidSphere(radius, slices, stacks);
	
	glPopMatrix();
		

		
}

// ///////////////////////////////////////////////////////////
// function: DrawDataSet3()
//
// creation date:	12/10/00
// last modified:	06/03/01
// purpose: draw the set of vertices in a 3-d object
//
// arguments: obj is a 3-d object holding the vertices
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawDataSet3(Skeleton *obj)
{
	int count;

	if (IsVisibleDataSet3())
	{
	   glPushMatrix();

	   count = Vertex3::GetGlobalVertexCount();

	   glBegin(GL_POINTS);
	   for (int k2=0; k2 < count; k2++)
	   {
			
			if (obj->vert[k2].GetFlag() == GEOM_ON_CONVEX_HULL)
			{
				glPointSize(3.5);
				glColor3f(1.0, 1.0, 0.2);
			}
			else
			{
				glPointSize(2.5);
				glColor3f(0.0, 1.0, 0.9);
			}

			if (obj->vert[k2].IsPole())
			{
				glPointSize(3.0);
				glColor3f(1.0, 0.0, 1.0);
			}

			glVertex3f(obj->vert[k2].x, obj->vert[k2].y, obj->vert[k2].z);
	   }
	   glEnd();

	   glPopMatrix();

	}
}


// ///////////////////////////////////////////////////////////
// function: DrawVertexNormals()
//
// creation date:	06/03/01
// last modified:	06/03/01
// purpose: draw all vertex normals
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawVertexNormals()
{
      int count = Vertex3::GetGlobalVertexCount();

	   for (int k2=0; k2 < count; k2++)
	   {
			DrawVertexNormal(k2);

	   }
	
}


// ///////////////////////////////////////////////////////////
// function: DrawVertexNormals()
//
// creation date:	24/04/01
// last modified:	24/04/01
// purpose: draw all face normals
//
// arguments: tetraList whose face normals have to be drawn
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawFaceNormals(TetraList& tetraList)
{

	if (!IsVisibleFaceNormal()) return;


	TetraList::Itr start = tetraList.Begin();
	TetraList::Itr end = tetraList.End();

	while (start != end)
	{
		Tetrahedron* tetra = *start++;

		DrawFaceNormal(tetra->F(0));
		DrawFaceNormal(tetra->F(1));
		DrawFaceNormal(tetra->F(2));
		DrawFaceNormal(tetra->F(3));

	}
}



// ///////////////////////////////////////////////////////////
// function: DrawVoronoiCell()
//
// creation date:	12/02/01
// last modified:	12/02/01
// purpose: draw a Voronoi cell from a Delaunay vertex (site)
//
// arguments: pointIndex is a index to the vertex list
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawVoronoiCell(int pointIndex)
{
#ifndef _DEBUG_STRICT
	assert (pointIndex < Vertex::GetGlobalVertexCount())
#endif
	glPushMatrix();

    DrawVertexNormal(pointIndex);

	if (!IsVisibleVoronoiCell()) return;

	Vertex3* globalList;
	globalList = Vertex3::GetGlobalVertexList();

	Vertex3 *v = &globalList[pointIndex];

	if (v->neigh->Size() > 0)
	{
		TetraList::Itr start = v->neigh->Begin();
		TetraList::Itr end   = v->neigh->End();

		// draw poles of the 3-d Voronoi cell
		Vertex3 poleMinus;
		Vertex3 polePlus;
		MedialAxisTransformer mat;
        mat.FindPolesFromDelaunayVertex(pointIndex, poleMinus, polePlus);
		// draw pole-
		glPointSize(8.0);
		glBegin(GL_POINTS);
			glColor3f(1.0, 0.0, 1.0);
			glVertex3f(poleMinus.x, poleMinus.y, poleMinus.z);
		glEnd();
		// draw pole+
		glBegin(GL_POINTS);
			glColor3f(0.1, 7.0, 0.2); // green
			glVertex3f(polePlus.x, polePlus.y, polePlus.z);
		glEnd();
		
		for (; start != end; start++)
		{
			Tetrahedron* tetra = *start;
			Vertex3 vv = tetra->Centre();
			glPointSize(3.0);
			glBegin(GL_LINES);
				glColor3f(0.9, 0.2, 1.0);
				glVertex3f(v->x, v->y, v->z);
				glColor3f(0.6, 0.0, 0.2);
				glVertex3f(vv.x, vv.y, vv.z);
			glEnd();

			glPointSize(7.0);
			glBegin(GL_POINTS);
				if (v->GetFlag() == GEOM_ON_CONVEX_HULL)
				{
					glColor3f(1.0, 1.0, 1.0);
				}
				else
				{
					glColor3f(0.6, 0.6, 1.0);
				}
				glVertex3f(v->x, v->y, v->z);
			glEnd();
		
			glPointSize(4.0);
			glBegin(GL_POINTS);
				glColor3f(1.0, 0.4, 0.345);
				glVertex3f(vv.x, vv.y, vv.z);
			glEnd();
		}
	}

	glPopMatrix();
}

// ///////////////////////////////////////////////////////////
// function: DrawVertexNormal()
//
// creation date:	07/03/01
// last modified:	07/03/01
// purpose: draw the normal vector to a vertex
//
// arguments: id of the vertex whose normal has to be draw
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawVertexNormal(int vertexId)
{
	if (!IsVisibleVertexNormal()) return;

	Vertex3 *vertex = Vertex3::GetVertex(vertexId);

	Vector3 vector = vertex->Normal();
	
	glPushMatrix();

	// the normal
	glLineWidth(0.05);
	double offset0 = GetNormalFactor();
	glBegin(GL_LINES);
		glColor3f(0.5, 0.9, 0.7);
		glVertex3f(vertex->x, vertex->y, vertex->z);
		glColor3f(0.5, 0.7, 0.9);
		glVertex3f(vertex->x+vector.x*offset0, vertex->y+vector.y*offset0, vertex->z+vector.z*offset0);
	glEnd();

	// tip of normal
	glPointSize(2.0);
	double offset1 = offset0+0.001*offset0;
	double offset2 = offset1+0.001*offset0;
	glBegin(GL_POINTS);
		glColor3f(1.0, 0.999, 1.0);
		glVertex3f(vertex->x+vector.x*offset1, vertex->y+vector.y*offset1, vertex->z+vector.z*offset1);
		glColor3f(1.0, 0.999, 1.0);
		glVertex3f(vertex->x+vector.x*offset2, vertex->y+vector.y*offset2, vertex->z+vector.z*offset2);
	glEnd();
	glPopMatrix();

	/*
	AppOut("vertex normal ");
	AppOut(vector.x);
	AppOut(vector.x);
	AppOut(vector.x);
	AppEndl();
	*/
}

// ///////////////////////////////////////////////////////////
// function: DrawFaceNormal()
//
// creation date:	07/03/01
// last modified:	07/03/01
// purpose: draw the normal vector to a vertex
//
// arguments: face whose normal has to be draw
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawFaceNormal(Face3 *face)
{
	if (!IsVisibleFaceNormal()) return;
	if (!IsFaceOnConvexHull(face)) return;

	Vertex3 tmpVertex;
	Vertex3* vertex = &tmpVertex;
	// center of face: use simple averge
	vertex->x = (face->V(0)->x + face->V(1)->x + face->V(2)->x)/3;
	vertex->y = (face->V(0)->y + face->V(1)->y + face->V(2)->y)/3;
	vertex->z = (face->V(0)->z + face->V(1)->z + face->V(2)->z)/3;

	/*
	// if no normal has been calculate before 
	// then do it now (non-procossed normal is 0,0,0)
	if (face->Normal().x == face->Normal().y 
		&& face->Normal().y == face->Normal().z 
		&& face->Normal().z == 0.0)
	{
		face->MakeNormal();
	}
	*/

	// if normal has not been normalized 
	// then create a temporary unit normal 
	Vector3 vector = face->Normal();
	if (vector.Magnitude() < 0.999 || vector.Magnitude() > 1.001)
	{
		vector.Normalize();
	}

	glPushMatrix();

	// the normal
	glLineWidth(0.05);
	double offset0 = GetNormalFactor();
	glBegin(GL_LINES);
		glColor3f(0.99, 0.8, 0.6);
		glVertex3f(vertex->x, vertex->y, vertex->z);
		glColor3f(0.88, 0.5, 0.7);
		glVertex3f(vertex->x+vector.x*offset0, vertex->y+vector.y*offset0, vertex->z+vector.z*offset0);
	glEnd();

	// tip of normal
	glPointSize(2.0);
	double offset1 = offset0+0.001*offset0;
	double offset2 = offset1+0.001*offset0;
	glBegin(GL_POINTS);
		glColor3f(0.99, 0.8, 1.0);
		glVertex3f(vertex->x+vector.x*offset1, vertex->y+vector.y*offset1, vertex->z+vector.z*offset1);
		glColor3f(0.99, 0.8, 1.0);
		glVertex3f(vertex->x+vector.x*offset2, vertex->y+vector.y*offset2, vertex->z+vector.z*offset2);
	glEnd();
	glPopMatrix();


}

// ///////////////////////////////////////////////////////////
// function: DrawGrid()
//
// creation date:	24/03/01
// last modified:	24/03/01
// purpose: draw a grid in space
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawGrid()
{
	if (!IsVisibleGrid()) return;

	glPushMatrix();

	glLineWidth(1.0);

		int numLines = 5;
		float size = 0.5;
		float minx = -size;
		float maxx = +size;
		float miny = -size;
		float maxy = +size;
		float minz = -size;
		float maxz = -size;
		float step = ((maxx - minx)/2)/(float)(numLines);// + (float)(numLines%2);
		float delta;

		float off = step;
		if (numLines < 6)
		{
			off = 0.0;
		}
	
		float col =0.30;
		// grid 1: vertical lines
		for (delta = minx; delta <= (maxx+off); delta += step)
		{
			glBegin(GL_LINES);
				glColor3f(col, col, col);
				glVertex3f(delta, miny, minz);
				glColor3f(col, col, col);
				glVertex3f(delta, maxy, maxz);
			glEnd();
		}
		// grid 1: horizontal lines
		for (delta = miny; delta <= (maxy+off); delta += step)
		{	
			glBegin(GL_LINES);
				glColor3f(col, col, col);
				glVertex3f(minx, delta, minz);
				glColor3f(col, col, col);
				glVertex3f(maxx, delta, maxz);
			glEnd();
		}

		// bottom plane
		maxx = +size;
		minx = -size;
		maxy = -size;
		miny = -size;
		maxz = +size;
		minz = -size;
		// grid 2: vertical lines
		for (delta = minx; delta <= (maxx+off); delta += step)
		{
			glBegin(GL_LINES);
				glColor3f(col, col, col);
				glVertex3f(delta, miny, minz);
				glColor3f(col, col, col);
				glVertex3f(delta, maxy, maxz);
			glEnd();
		}
		// grid 2: horizontal lines
		for (delta = -size; delta <= (+size+off); delta += step)
		{	
			glBegin(GL_LINES);
				glColor3f(col, col, col);
				glVertex3f(minx, miny, delta);
				glColor3f(col, col, col);
				glVertex3f(maxx, maxy, delta);
			glEnd();
		}

		// left plane
		maxx = +size;
		minx = +size;
		maxy = +size;
		miny = -size;
		maxz = +size;
		minz = -size;
		// grid 3: vertical lines
		for (delta = -size; delta <= (+size+off); delta += step)
		{
			glBegin(GL_LINES);
				glColor3f(col, col, col);
				glVertex3f(minx, miny, delta);
				glColor3f(col, col, col);
				glVertex3f(maxx, maxy, delta);
			glEnd();
		}
		// grid 3: horizontal lines
		for (delta = -size; delta <= (+size+off); delta += step)
		{	
			glBegin(GL_LINES);
				glColor3f(col, col, col);
				glVertex3f(minx, delta, minz);
				glColor3f(col, col, col);
				glVertex3f(maxx, delta, maxx);
			glEnd();
		}
	

	glPopMatrix();
}

// ///////////////////////////////////////////////////////////
// function: DrawBackground()
//
// creation date:	24/03/01
// last modified:	24/03/01
// purpose: draw a textured background in space
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawBackground()
{
	if (!IsVisibleBackground()) return;

	glPushMatrix();

	glPopMatrix();
}


// ///////////////////////////////////////////////////////////
// function: DrawFaceArray()
//
// creation date:	24/04/01
// last modified:	24/04/01
// purpose: draw an array of face indices (polygon mesh)
//
// arguments: face array
//
// return value: none
// ///////////////////////////////////////////////////////////

void GeometryVisualizer::DrawFaceArray(unsigned long *faceArray, long faceCount)
{
	if (faceCount <= 0) return;

	int mode = GetPolygonMode();

	if (mode == GV_SMOOTHSHADING || mode == GV_FLATSOLID || mode == GV_WIREANDSHADE)
	{
		DrawShadedFaceArray(faceArray, faceCount);
	}

	if (mode == GV_WIRE || mode == GV_WIREANDSHADE)
	{
		DrawWireFaceArray(faceArray, faceCount);
	}
}


// ///////////////////////////////////////////////////////////
// function: DrawShadedFaceArray()
//
// creation date:	24/04/01
// last modified:	24/04/01
// purpose: draw an array of face indices (polygon mesh)
//
// arguments: face array
//
// return value: none
// ///////////////////////////////////////////////////////////

void GeometryVisualizer::DrawShadedFaceArray(unsigned long *faceArray, long faceCount)
{
	if (faceCount <= 0) return;


	glPushMatrix();


	if (IsVisibleLighting())
	{
		glEnable(GL_LIGHTING);
	}
	else
	{
		glDisable(GL_LIGHTING);
	}

	glDisable(GL_CULL_FACE);
	glLineWidth(1.0);

	glPolygonMode(GL_BACK, GL_FILL);
	glPolygonMode(GL_FRONT, GL_FILL);


	GLfloat c1[3];
	GLfloat c2[3];
	GLfloat c3[3];
	if (GetPolygonMode() == GV_FLATSOLID)
	{
		c1[0] = c2[0] = c3[0] = 0.70;
		c1[1] = c2[1] = c3[1] = 0.70;
		c1[2] = c2[2] = c3[2] = 0.70;
		if (IsVisibleLighting())
		{
			glDisable(GL_LIGHTING);
			SetVisibleLighting(false);
		}


	}
	else
	{
		if (GetPolygonMode() == GV_SMOOTHSHADING)
		{
			c1[0] = 0.61; c2[0] = 0.60; c3[0] = 0.60;
			c1[1] = 0.71; c2[1] = 0.70; c3[1] = 0.70;
			c1[2] = 0.84; c2[2] = 0.84; c3[2] = 0.84;			c1[0] = 0.65; c2[1] = 0.60; c3[2] = 0.55;
		}
		else // wire and shade
		{
			c1[0] = 0.61; c2[0] = 0.60; c3[0] = 0.60;
			c1[1] = 0.71; c2[1] = 0.70; c3[1] = 0.70;
			c1[2] = 0.81; c2[2] = 0.80; c3[2] = 0.80;				c1[0] = 0.65; c2[1] = 0.60; c3[2] = 0.55;
		}
	}

	for (int i = 0; i < faceCount*3; i +=3)
	{
		// get triangles to draw from faceIndex array
		Vertex3 *v0 = Vertex3::GetVertex(faceArray[i+0]);
		Vertex3 *v1 = Vertex3::GetVertex(faceArray[i+1]);
		Vertex3 *v2 = Vertex3::GetVertex(faceArray[i+2]);

		glBegin(GL_TRIANGLES);

			//glColor3f(1.0f, 0.0f, 0.0f);
			glColor3f(c1[0], c2[0], c3[0]);
			glNormal3f(v0->normal.x, v0->normal.y, v0->normal.z);
			glVertex3f(v0->x, v0->y, v0->z);

			//glColor3f(1.0f, 0.5f, 0.0f);
			glColor3f(c1[1], c2[1], c3[1]);
			glNormal3f(v1->normal.x, v1->normal.y, v1->normal.z);
			glVertex3f(v1->x, v1->y, v1->z);

			//glColor3f(1.0f, 0.0f, 0.5f);
			glColor3f(c1[2], c2[2], c3[2]);
			glNormal3f(v2->normal.x, v2->normal.y, v2->normal.z);
			glVertex3f(v2->x, v2->y, v2->z);

		glEnd();
	}

	glPolygonMode(GL_BACK, GL_LINE);
	glPolygonMode(GL_FRONT, GL_LINE);

	
	glDisable(GL_LIGHTING);
	glEnable(GL_CULL_FACE);
	
	glPopMatrix();
}



// ///////////////////////////////////////////////////////////
// function: DrawWreFaceArray()
//
// creation date:	24/04/01
// last modified:	24/04/01
// purpose: draw an array of face indices (polygon mesh)
//
// arguments: face array
//
// return value: none
// ///////////////////////////////////////////////////////////

void GeometryVisualizer::DrawWireFaceArray(unsigned long *faceArray, long faceCount)
{
	if (faceCount <= 0) return;

	int mode = GetPolygonMode();

	glPushMatrix();

	glDisable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);

	glPolygonMode(GL_BACK, GL_LINE);
	glPolygonMode(GL_FRONT, GL_LINE);

	GLfloat r, b, g, off, delta;

	if (mode == GV_WIRE)
	{
		
		r = 0.9f;
		g = 0.0f;
		b = 0.25f;
		off = 0.1f;
		delta = 0.2;
		/*
		r = 0.2f;
		g = 0.2f;
		b = 0.2f;
		off = 0.05f;
		delta = 0.05;
		*/
		glLineWidth(1.9);
	}
	
	else //  mode == GV_WIREANDSHADE
	{
		r = 0.5f;
		g = 0.5f;
		b = 0.5f;
		off = 0.01f;
		delta = 0.01;
		glLineWidth(2.5);
	}
	


	for (int i = 0; i < faceCount*3; i +=3)
	{
		// get triangles to draw from faceIndex array
		Vertex3 *v0 = Vertex3::GetVertex(faceArray[i+0]);
		Vertex3 *v1 = Vertex3::GetVertex(faceArray[i+1]);
		Vertex3 *v2 = Vertex3::GetVertex(faceArray[i+2]);


		glBegin(GL_TRIANGLES);
	
			glColor3f(r-delta, g, b+off-delta);
			glVertex3f(v0->x, v0->y, v0->z);

			glColor3f(r, g, b+off);
			glVertex3f(v1->x, v1->y, v1->z);

			glColor3f(r, g, b+2*off);
			glVertex3f(v2->x, v2->y, v2->z);

		glEnd();
	}

	glPolygonMode(GL_BACK, GL_LINE);
	glPolygonMode(GL_FRONT, GL_LINE);

	glEnable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);
	
	glPopMatrix();
}




// ///////////////////////////////////////////////////////////
// function: InitializeContext()
//
// creation date:	27/03/01
// last modified:	27/03/01
// purpose: initlization of the visual context: i
// i.e. ogl display lists
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::InitializeContext()
{
	// initalization of display lists

	// create grid display list

	// create coordinate system display list

}

// ///////////////////////////////////////////////////////////
// function: DrawCoordinateSystem()
//
// creation date:	27/03/01
// last modified:	27/03/01
// purpose: draw the three axis of the coordinate system
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawCoordinateSystem()
{
	if (!IsVisibleCoordinateSystem()) return;

	glColor3f(1.0, 1.0, 1.0);
	glPointSize(3.0);
	glBegin(GL_POINTS);
		glVertex3f(0.0, 0.0, 0.0);
		glVertex3f(1.0, 0.0, 0.0);
		glVertex3f(0.0, 1.0, 0.0);
		glVertex3f(0.0, 0.0, 1.0);
	glEnd();
	glLineWidth(2.51);
	// x-axis red
	glBegin(GL_LINES);
		glColor3f(0.4, 0.0, 0.0);
		glVertex3f(0.0, 0.0, 0.0);
		glColor3f(0.99, 0.08, 0.23);
		glVertex3f(1.0, 0.0, 0.0);
	glEnd();
	// y-axis green
	glBegin(GL_LINES);
		glColor3f(0.0, 3.0, 0.0);
		glVertex3f(0.0, 0.0, 0.0);
		glColor3f(0.31, 0.99, 0.05);
		glVertex3f(0.0, 1.0, 0.0);
	glEnd();
	// z-axis blue
	glBegin(GL_LINES);
		glColor3f(0.0, 0.0, 0.4);
		glVertex3f(0.0, 0.0, 0.0);
		glColor3f(0.3, 0.1, 0.99);		
		glVertex3f(0.0, 0.0, 1.0);
	glEnd();
	
}


// ///////////////////////////////////////////////////////////
// function: DrawBackgroundPlane()
//
// creation date:	29/03/01
// last modified:	29/03/01
// purpose: draw a large grid representing the floor
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////
void GeometryVisualizer::DrawBackgroundPlane()
{
	if (!IsVisibleBackgroundPlane()) return;

	glPushMatrix();


		int numLines = 25;
		float size = 5.0;
		float minx = -size;
		float maxx = +size;
		float miny = -size;
		float maxy = +size;
		float minz = -size;
		float maxz = -size;
		float step = ((maxx - minx)/2)/(float)(numLines);// + (float)(numLines%2);
		float delta;

		float off = step;
		if (numLines < 6)
		{
			off = 0.0;
		}
	
		float col =0.20;
		float cd = 0.11; // color delta

		// bottom plane
		maxx = +size;
		minx = -size;
		maxy = (float)GetBottomOfBox();
		miny = (float)GetBottomOfBox();
		maxz = +size;
		minz = -size;
		// grid 2: vertical lines
		for (delta = minx; delta <= (maxx+off); delta += step)
		{
			if (delta > -0.001 && delta <= +0.001)
			{
				glLineWidth(2.0);
				col = 0.06;
			}
			else
			{
				glLineWidth(1.0);
				col = 0.20;
			}
			glBegin(GL_LINES);
				glColor3f(col+cd, col+cd, col+cd);
				glVertex3f(delta, miny, minz);
				glColor3f(col, col, col);
				glVertex3f(delta, maxy, maxz);
			glEnd();
		}
		// grid 2: horizontal lines
		cd = 0.0;
		for (delta = -size; delta <= (+size+off); delta += step)
		{	
			if (delta > -0.001 && delta <= +0.001)
			{
				glLineWidth(2.0);
				col = 0.15;
			}
			else
			{
				glLineWidth(1.0);
				col = 0.20;
			}
			cd += 0.005;
			glBegin(GL_LINES);
				glColor3f(col+cd, col+cd, col+cd);
				glVertex3f(minx, miny, delta);
				glColor3f(col+cd, col+cd, col+cd);
				glVertex3f(maxx, maxy, delta);
			glEnd();
		}

	glPopMatrix();
}



// ///////////////////////////////////////////////////////////
// function: IsSuperVertex()
//
// creation date:	11/04/01
// last modified:	12/04/01
// purpose: check if a vertex is from 
//          the super tetrahedron
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

bool IsSuperVertex(Face3 *f)
{
Vertex3 *a[4];

	// get supertetrahedron vertices
	a[0] = Vertex3::GetGlobalVertexList() + (Vertex3::GetGlobalVertexCount()-4);
	a[1] = a[0] + 1;
	a[2] = a[0] + 2;
	a[3] = a[0] + 3;
	

		bool t0 = VERTEX3_IS_EQUALP(a[0],f->V(0))||VERTEX3_IS_EQUALP(a[1],f->V(0))||VERTEX3_IS_EQUALP(a[2],f->V(0))||VERTEX3_IS_EQUALP(a[3],f->V(0));
		bool t1 = VERTEX3_IS_EQUALP(a[0],f->V(1))||VERTEX3_IS_EQUALP(a[1],f->V(1))||VERTEX3_IS_EQUALP(a[2],f->V(1))||VERTEX3_IS_EQUALP(a[3],f->V(1));
		bool t2 = VERTEX3_IS_EQUALP(a[0],f->V(2))||VERTEX3_IS_EQUALP(a[1],f->V(2))||VERTEX3_IS_EQUALP(a[2],f->V(2))||VERTEX3_IS_EQUALP(a[3],f->V(2));

		bool superVertices = t0&&t1&&t2;
	
		return superVertices ;
}



// ///////////////////////////////////////////////////////////
// function: IsTouchingSuperVertices
//
// creation date:	11/04/01
// last modified:	12/04/01
// purpose: check if a face lies or touches a vertex of
//          the super tetrahedron
//
// arguments: none
//
// return value: none
// ///////////////////////////////////////////////////////////

bool IsTouchingSuperVertices(Face3 *f)
{

	Vertex3 *a[4];

	// get supertetrahedron vertices
	a[0] = Vertex3::GetGlobalVertexList() + (Vertex3::GetGlobalVertexCount()-4);
	a[1] = a[0] + 1;
	a[2] = a[0] + 2;
	a[3] = a[0] + 3;
	

		bool t0 = VERTEX3_IS_EQUALP(a[0],f->V(0))||VERTEX3_IS_EQUALP(a[1],f->V(0))||VERTEX3_IS_EQUALP(a[2],f->V(0))||VERTEX3_IS_EQUALP(a[3],f->V(0));
		bool t1 = VERTEX3_IS_EQUALP(a[0],f->V(1))||VERTEX3_IS_EQUALP(a[1],f->V(1))||VERTEX3_IS_EQUALP(a[2],f->V(1))||VERTEX3_IS_EQUALP(a[3],f->V(1));
		bool t2 = VERTEX3_IS_EQUALP(a[0],f->V(2))||VERTEX3_IS_EQUALP(a[1],f->V(2))||VERTEX3_IS_EQUALP(a[2],f->V(2))||VERTEX3_IS_EQUALP(a[3],f->V(2));

		bool touchingSuperVertices = t0||t1||t2; //||r3;

		return touchingSuperVertices;
}

